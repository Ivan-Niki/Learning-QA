
Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тест-кейсы, 
в соответствии c определенными ранее критериями качества и целями тестирования. 
Цель тест-дизайна – создать наборы тестовых случаев, обеспечивающих оптимальное тестовое покрытие.

Техники тестирования (Test techniques, Test design techniques) – методы, используемые для создания и/или выбора входных данных и условий выполнения тестов.

Техники тестирования (Test techniques, Test design techniques) – методы, используемые для создания и/или выбора входных данных и условий выполнения тестов.



================== 1. Эквивалентное разбиение (Equivalence partitioning – EP) =================

Техника эквивалентного разбиения (классы эквивалентности) – это разделение диапазона возможных вводимых значений на группы (классы) эквивалентных по своему влиянию на систему. Эта техника помогает не только сокращать количество тестов, но и сохранять приемлемое тестовое покрытие.
Рассмотрим для примера перевод денег в банке. Размер комиссии зависит от суммы перевода:
•	от 1 до 999 долларов включительно – 0%
•	от 1000 до 4999 долларов включительно – 5%
•	от 5000 долларов – 7%
Максимальная сумма перевода – 100000 долларов, при этом дробные числа не учитываются.
Попробуем выяснить, сколько требований будет в этом случае. В этом помогут классы эквивалентности:
•	1-999 => ожидаем комиссию 0%
•	1000-4999 => ожидаем комиссию 5%
•	5000-100000 => ожидаем комиссию 7%
Выбранные значения для проверки: 500, 2500, 7500.
•	На значение 500 система отреагирует так же, как и на любое другое значение из первого диапазона;
•	На значение 2500 система отреагирует так же, как и на любое другое значение из второго диапазона;
•	На значение 7500 система отреагирует так же, как и на любое другое значение из третьего диапазона.


Пример 2:
Рассмотрим поведение текстового поля Order Pizza (“Заказать пиццу”).
Значения пиццы от 1 до 10 считаются валидными. Отображается сообщение об успехе.
Значения от 11 до 99 считаются недопустимыми для заказа, и появляется сообщение об ошибке: “Можно заказать только 10 пицц”.

Вот условия проверки:
- Любое число меньше 1, введенное в поле Order Pizza, недействительно.
- Валидными считаются числа от 1 до 10.
- Любое число больше 10 считается недействительным.
- Любое трехзначное число также считается недействительным.

Из-за большого количества возможных входных значений мы не можем протестировать каждый отдельный случай. Для решения этой проблемы мы используем методику эквивалентного разбиения, в которой мы делим возможные входные значения на группы или наборы.


  Partition 1 |  Partition 2 |   Partition 3    |  Partition 4 |
  (Invalid)   |   (Valid)    |    (Invalid)     |   (Invalid)  |
--------------|--------------|------------------|--------------|
            0 | 1         10 | 11            99 | 100          |

Разделенные наборы называются эквивалентными разбиениями или эквивалентными классами. Мы выбираем только одно значение из каждого класса для тестирования. Идея состоит в том, что если одно условие/значение в классе проходит, то все остальные также пройдут. Аналогично, если одно условие в наборе не выполняется, то все остальные условия тоже не выполняются.



=============== 2. Анализ граничных значений (Boundary Value Analysis - BVA) ==============

Граничные значения – это значения, в которых один класс эквивалентности переходит в другой. По своей сути это техника, которая дополняет технику классов эквивалентности.
Важно проверять граничные значения, потому что именно на границах чаще всего допускаются ошибки при написании кода и формулировании требований.
Например, неопытный программист при постановке «не больше 1000» может поставить значение <1000.
Вернемся к примеру с комиссией:
•	от 1 до 999 долларов включительно – 0%
•	от 1000 до 4999 долларов включительно – 5%
•	от 5000 долларов – 7%
Максимальная сумма перевода – 100000 долларов, при этом дробные числа не учитываются. Вспомним классы эквивалентности:
•	1-999 => ожидаем комиссию 0%
•	1000-4999 => ожидаем комиссию 5%
•	5000-100000 => ожидаем комиссию 7%
Граничные значения: 1, 999, 1000, 4999, 5000, 100000.
С учетом классов эквивалентности и граничных значений выбираем значения для проверки: 1, 500, 999, 1000, 2500, 4999, 5000, 7500, 100000.



Анализ граничных значений – это методика тестирования ПО, которая проверяет поведение системы на границах значений входных данных.

Граничные значения – это крайние точки, такие как начальная-конечная, нижняя-верхняя, максимальная-минимальная.
Основная идея анализа граничных значений заключается в выборе таких входных значений, как:
- Минимум
- Чуть выше минимума
- Стандартное значение
- Чуть ниже максимума
- Максимум

В граничном тестировании разделение на эквивалентные классы играет важную роль.
Граничное тестирование происходит после разделения на эквивалентные классы.


Пример 3:
В этом примере мы рассмотрим тест-кейсы граничных значений. Поле ввода должно принимать числа от 1 до 10.
_____________________________________________________________
Cценарий тестирования	    |    Ожидаемый результат         |
-------------------------------------------------------------|
Граничное значение = 0	    |    Система НЕ должна принимать |
Граничное значение = 1	    |    Система должна принимать    |
Граничное значение = 2	    |    Система должна принимать    |
Граничное значение = 9	    |    Система должна принимать    |
Граничное значение = 10	    |    Система должна принимать    |
Граничное значение = 11	    |    Система НЕ должна принимать |
-------------------------------------------------------------|


Пример 4:
Возьмём поле Username, в котором система вводит ограничение по длине от 3 до 20 символов.
Соответственно для проверки длины поля, мы можем выделить следующие классы:
--> 0-2 символов — выдаст ошибку, что Username имеет недостаточное количество символов
--> 3-20 символов — обработается верно
--> 21-бесконечность — выдаст ошибку, что Username превышает разрешённое количество символов.

Для проверки длины поля мы уже выделили 3 класса: от 0 до 2, от 3 до 20, от 21 и выше.
Соответственно можно выделить следующие границы переходов:

  (Invalid)   |   (Valid)    |    (Invalid)  
--------------|--------------|---------------
            2 | 3         20 | 21            

В рамках техники анализа граничных значений мы должны сделать тесты для проверки вышеуказанных значений:
-> 2: Bo
-> 3: Bat
-> 20: BatmanAndRobinReturn
-> 21: BatmanAndRobinForever
Тем самым мы убедимся в том, что все переходы из одного класса в другой обрабатываются правильно.

Существует 2 подхода к анализу граничных значений:
2 значения на границе (Two-value boundaries);
3 значения на границе (Three-value boundaries).

Проверка 2 значений на границе предполагает использование только граничного значения и на один минимальный шаг меньше (в случае с минимальной границей) или на один минимальный шаг больше (в случае с максимальной границей). Собственно говоря, в примере выше мы использовали именно этот подход. На каждой из границ позитивного класса мы проверили по 2 значения:
- Минимальная граница: 2, 3 символов
- Максимальная граница 20, 21 символов

Проверка 3 значений на границе предполагает использование граничного значения, на один минимальный шаг больше и на один минимальный шаг меньше границы. Таким образом для примера выше нам необходимо будет сделать следующие проверки:
- Минимальная граница: 2, 3, 4 символов
- Максимальная граница 19, 20, 21 символов

Выбор подхода обычно основывается на уровне рисков связанных с тестируемой областью. Чаще всего мы используем 2 значения, но в системах с повышенными рисками лучше использовать 3 значения.



=============== 3. Попарное тестирование (Pairwise Testing) ==============

Попарное тестирование – техника тест-дизайна, при которой тест-кейсы формируются так, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.
Pairwise testing — техника тест-дизайна, основанная на наблюдениях о том, что большинство дефектов вызвано взаимодействием не более двух факторов (дефекты, которые возникают при взаимодействии трех и более факторов, как правило менее критичны). Следовательно, выбирается пара двух тестовых параметров, и все возможные пары этих двух параметров отправляются в качестве входных параметров для тестирования. Pairwise testing сокращает общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные на тестирование.
Сформулировать суть попарного тестирования можно следующим образом: формирование таких наборов данных, в которых каждое тестируемое значение каждого из проверенных параметров хотя бы один раз сочетается с каждым тестируемым значением всех других проверяемых параметров.

Главные цели Pairwise Testing:
--> убрать избыточные проверки;
--> обеспечить хорошее тестовое покрытие;
--> выявить наибольшее количество багов на минимальном наборе тестов.


Рассмотрим более подробно суть попарного тестирования на примерах.

------- Пример 1 --------
Предположим, какое значение (например, налог) для человека рассчитывается на основании его пола, возраста и наличия детей – получаем три входных параметра, для каждого из которых для тестов выбираем любое из возможных значений. Например: 
-> пол – мужской или женский; 
-> возраст – до 25, от 25 до 60, свыше 60; 
-> наличие детей – да или нет. 

Для проверки правильности расчетов можно, конечно, перебрать все комбинации значений всех параметров (получится 12 проверок). А можно решить, что не нужно проверять сочетание значений всех параметров со всеми, а только убедиться, что проверятся все уникальные пары значений параметров. К примеру, с точки зрения параметров пола и возраста нужно убедиться, что точно проверим мужчину до 25, мужчину между 25 и 60, мужчину после 60, а также женщину до 25, женщину между 25 и 60, а также женщину после 60. И точно так для всех остальных пар параметров. И таким образом, можем получить гораздо меньше наборов значений (в них есть все пары значений, правда, некоторые дважды). Таким образом у нас получится всего 6 проверок.


------- Пример 2 --------
Есть два браузера Opera и Firefox. Имеются две операционные системы Windows и Linux. Здесь ничего не убавить, так как из них можно составить 4 конфигурации.
_______________________
№ |	Browser	|  OS      |
-----------------------|
1 |	Opera	|  Windows |
2 |	Firefox	|  Linux   |
3 |	Opera	|  Linux   |
4 |	Firefox	|  Windows |
-----------------------|

Предположим, сайт на двух языках: русский (RU) и английский (EN). Для полного перебора умножим эти 4 конфигурации на 2, то есть каждую из предыдущих конфигураций проверить с обоими языками. Но зачем? Вместо этого воспользуемся попарным подходом и вместо 8 конфигураций получим снова 4.
__________________________________
№ |	Browser	|    OS    | Language |
----------------------------------|
1 |	Opera	|  Windows |   RU     |
2 |	Firefox	|  Linux   |   RU     |
3 |	Opera	|  Linux   |   EN     |
4 |	Firefox	|  Windows |   EN     |
----------------------------------|

Далее сайт может использовать MySQL, Oracle и MSSQL как базу данных. Просто используя попарное тестирование 
получаем 7 конфигураций (а не 12 – предварительные 4х3, и тем более не 24 = 8х3).



-------------- Пример 3 --------------
Метод Pairwise используется, когда количество входных параметров велико. Например, мы хотим протестировать разделы системного диска с параметрами:

Type:          Primary, Logical, Single, Span, Stripe, Mirror, RAID-5
Size:          10, 100, 500, 1000, 5000, 10000, 40000
Format method: quick, slow
File system:   FAT, FAT32, NTFS
Cluster size:  512, 1024, 2048, 4096, 8192, 16384, 32768, 65536
Compression:   on, off

В Итоге получается 4 704 комбинацией случаев. Метод парного тестирования позволяет существенного сократить количество комбинаций.
Для удобства получения выходного множества тестов существует программа PICT (от Microsoft). Программа работает из командной строки.
Например, сохраним описанные ранее параметры в текстовый файл и назовем его Model.txt
В нужной папке вызываем командную строку. В командной строке вводим команду, содержащую входной и выходной файл:

pict model.txt > model_out.xls

Входной файл model.txt, в выходном файле model_out.xls будет содержаться таблица всех возможных тестов по методу парного тестирования. В нашем случае количество тест кейсов уменьшилось с 4704 до 60. Это существенно сократит 
время и ресурсы на тестирование.

Помимо PICT, есть множество других инструментов для расчёта уникальных пар. Например:
--> PairwiseTool - https://pairwise.teremokgames.com/



=============== 4. Тестирование каждого выбора (Each Choice Testing) ==============

Данная техника также имеет название "Метод минимальных проверок".
Суть техники: каждое значение каждого конкретного параметра должно использоваться хотя бы раз в тестовом наборе.
Таким образом, результирующее количество комбинаций будет равно количеству значений параметра с наибольшим диапазоном.
Другими словами, метод минимальных проверок - это когда минимальное количество тестов равно 
максимальному количеству значений какого-то параметра.



=============== 5. Тестирование базового выбора (Base Choice Testing) ==============

Данная техника также имеет название "Метод атомарных проверок".
Для данной стратегии мы должны определить базовые значения для каждого параметра, на основе которых 
создаются тест-кейсы, дополняемые другими значениями. 
Базовые значения фиксируются как обязательные в каждом тест-кейсе.
Базовыми значениями могут выбираться самые распространённые, самые маленькие и большие значения, критически важные значения, которые чаще всего применяются, или при использовании которых чаще всего возникают баги.
Суть техники: мы должны изменять значения каждого параметра по одному, сохраняя при этом значения других параметров, которые зафиксированы как базовые.

Алгоритм следующий:
1) Собираем таблицу, сначала выписывая самый рабочий, самый стандартный или часто используемый набор значений, приближенный к нашей жизни. Это будет наш "нулевой тест".
И если эта проверка с этим тестовым набором не работает, то у нас очень серьезная ошибка и дальнейшее тестирование этого функционала даже проводить бессмысленно. А если работает, то продолжаем создавать следующий набор, меняя ОДНО значение одного параметра!
Общее количество атомарных тестов считается по формуле: сумма значений минус количество параметров. Значений — восемь, параметров — три, в итоге — пять проверок. Особняком стоит наш "нулевой" тест, которым мы проверяем работоспособность тестируемой функциональности.

"Атомарки" — весьма удобная техника, чтобы тестировать нестабильные "сырые" продукты, потому что все причины ошибок мы видим сразу же.

Если ваш тестируемый продукт более зрелый, используйте деревья решений, S&T — based testing (тестирование на основании состояний и переходов) или pairwise.




=============== 6. Тестирование всех комбинаций (All Combinations) ==============

Исчерпывающее тестирование с использованием в качестве входящих данных всех возможных комбинаций параметров.
Имеет смысл только в том случае, когда количество комбинаций небольшое, и вы не потратите на это много времени.



=============== 7. Тестирование состояний и переходов (State Transition testing) ==============

State & Transition Diagram (сокращенно S&T) — схема состояний и переходов. Техника для визуализации ТЗ. Она наглядно показывает, как некий объект переходит из одного состояния в другое.
Вот объект находился в состоянии А, потом произошло какое-то действие, и он попал в состояние В. Потом он попадет в состояние С и другие... Принцип не меняется, было одно состояние, стало другое.
Проще говоря, у нас есть объект, который может находиться в разных состояниях. Переход от одного состояния к другому обычно чем-то обусловлен, например, каким-нибудь действием над объектом. Эти состояния и действия над объектом нам необходимо смоделировать. Под объектом мы обычно понимаем тестируемую фичу или ее часть.

Основные термины и определения:
1) Состояние (State);
2) Переход (Transition);
3) Событие (Event);
4) Действие (Action).

Состояние (State) - представлено в виде круга на диаграмме (или другой геометрической фигурой, например, прямойгольником). Это состояние приложения, в котором оно ожидает одно или более событий. События могут вызывать смену состояния и/или инициировать действия;

Переход (Transition) - представлено в виде стрелки на диаграмме. Это преобразование одного состояния в другое, происходящее по событию.

Событие (Event) - представлено в виде текста над переходом (стрелкой). Это что-то, что заставляет приложение изменить своё состояние.
События бывают двух видов:
--> внешние - поступают извне приложения (то есть через интерфейс приложения);
--> внутренние - генерируются самим приложением (например, событие "истёк таймер");
Когда происходит событие, приложение может поменять (или не поменять) состояние и выполнить (или не выполнить) действие.
События могут иметь параметры (например, событие "Оплата" может иметь параметры "Наличные деньги", "Чек" или "Кредитная карта").

Действие (Action) - представлено в виде текста после знака "/" над переходом (стрелкой). Это реакция программы на событие. Инициируется сменой состояния (например, "Напечатать билет", "Показать на экране" и др.).
Обычно действия создают что-то, что является выходными/возвращаемыми данными системы (ответом сервера).
Действия возникают при переходах, сами по себе состояния пассивны.

Таким образом, на S&T диаграмме у нас могут быть представлены следующие элементы:
- Точка входа (Entry point). На диаграмме всё начинается с точки входа (обозначается кружочком черного цвета).
- Точка выхода (Exit point). ТОчкой выхода заканчивается диаграмма (обозачается черным кружочком с белой каймой по краю).
- Состояния: [State 1] ---> [State 2] ---> [State 3] и т.д.
- Переходы (Transitions): стрелки между состояниями.
- События (Events) / Действия (Actions). Это записи над стрелками переходов (например: )



Теперь на примере тестирования игры:
Попробуем сделать диаграмму состояний и переходов какого-нибудь объекта в игре. Возьмем для примера Молокозавод. Обычное строение, которое имеет несколько состояний.
1) Первое состояние — строения не существует в игре. Оно еще не куплено.
2) Второе состояние — строительство на игровом поле.
3) Следующее состояние — стадия открытия.
4) Четвертое состояние — построено.

Далее для простоты анализа все это можно представить визуально:
--> кружочки — состояния объекта;
--> стрелочки — то, благодаря чему из состояния А в состояние В. Это действие, но его может совершить не только пользователь, но и система сама. Например, задача запустилась автоматически в 10 часов вечера.

Такая схема позволяет нам сразу визуально оценить, какие переходы вообще возможны и что надо протестировать. Ведь нам надо протестировать и эту стрелку, и эту... Так что стрелочки — это наши готовые тест-кейсы!

Далее давайте посмотрим, какие действия влияют на изменение состояния и снова изобразим это на рисунке.
1) Купить 
2) Подождать 1 час или Ускорить за кеш
3) Внести материалы

Кроме действий, которые влияют на объект и изменяют его состояние, есть еще действия, которые влияют на объект, но не изменяют его состояние. Например, поворот или перемещение здания. Такое действие затрагивает сам объект, но не влияет на его состояние. Их также необходимо определить и отобразить на нашей диаграмме.

После того, как определили основные состояния и действия над объектом, нам необходимо их перенести в табличный формат, чтобы составить чек-листы для проверки. Сделать это очень просто, таблица будет состоять всего из двух столбцов, в одном будут состояния, в другом действия:

_________________________________________
№ |	Состояние        |  Действие        |
----------------------------------------|
1 |	Не существует    | Купить           |
2 |	Строится	     | Ускорить за кэш  |
3 |	Ожидает открытия | Подождать 1 час  |
4 |	Построено	     | Внести материалы |
----------------------------------------|



=============== 8. Варианты использования (Use Case Testing) ==============

Use case (также юзкейс, сценарий использования) – это сценарий взаимодействия пользователя (или пользователей) с программным продуктом для достижения конкретной цели.
Use case — это сценарии, описывающие то как actor (обычно человек, но может быть и другая система) пользуется системой для достижения определенной цели. Варианты использования описываются с точки зрения пользователя, а не системы. Внутренние работы по поддержанию работоспособности системы не являются частью варианта использования.
Хотя бы один тест-кейс должен проверять основной сценарий и хотя бы по одному кейсу должно приходится на альтернативные сценарии.
Юзкейсы — отличная основа для формирования тест-кейсов. Это, по сути, пригодные для тестирования требования с понятной целью и путями ее достижения. Тестирование по сценариям использования (use case testing) позволяет обнаружить в приложении недостатки,  которые сложно найти, например, при юнит-тестировании.

Юзкейсы содержат следующие сведения:
--> кто использует сайт или приложение
--> что пользователь хочет сделать
--> цель пользователя
--> шаги, которые делает пользователь, чтобы совершить определенное действие
--> описание того, как сайт или приложение реагируют на действия пользователя.

Юзкейсы не содержат детали реализации, а также описания пользовательского интерфейса или экранов.
В общем, в юзкейсе описывается не каким образом программа делает что-либо, а что именно она делает. Именно этого подхода и нужно придерживаться, создавая юзкейсы.
В отличие от user story, которая излагается от имени какого-то конкретного пользователя, в use case может быть описано взаимодействие (с определенной целью) нескольких участников. Например:
- покупка товара в магазине (Покупатель – Продавец);
- отправка письма по электронной почте (Отправитель – Почтовый клиент);
- запрос страницы браузером (браузер – веб-сервер).

--------- Как написать use case? ---------
В зависимости от целевой аудитории юзкейсы могут отличаться. Но все они должны включать следующие компоненты:
--> Краткое описание. Оно поясняет общую суть юзкейса.
--> Предварительные условия. Это действия, которые пользователь должен выполнить до начала выполнения юзкейса.
--> Система. Здесь указывается продукт, сервис или программное обеспечение, которые будут использованы в тесте.
--> Действующие лица. Действующее лицо (или актор) – это пользователь, который взаимодействует с системой и демонстрирует определенное поведение. Это также может быть другая система или целая организация. В юзкейсе могут быть указаны первичные и вторичные акторы. Первичный может инициировать взаимодействие с системой, а вторичный – предоставлять системе необходимые сервисы.
--> Основной поток или основной сценарий. Это конкретная последовательность действий и взаимодействий между действующими лицами и системой. Это типичный рабочий процесс, в ходе которого действующее лицо получает ожидаемый результат.
--> Альтернативный поток. Помимо типичного рабочего процесса, система может иметь альтернативный сценарий взаимодействия.
--> Поток исключений. Поток, который не позволяет пользователю достичь желаемого результата.
--> Пост-условия. Это действия, которые должны быть выполнены по завершению юзкейса.

--------- Пример Use case ---------
Теперь, когда мы разобрались в основах, давайте создадим юзкейс для реального проекта.
В качестве примера возьмем веб-приложение для доставки еды. Приложение может использоваться для размещения и отслеживания заказов, обработки платежей и связи с рестораном, который доставляет заказ.
Вот возможный вариант юзкейса для описанного приложения:

- Описание юзкейса. Пользователь может заказать еду через Интернет.
- Система. Веб-приложение для доставки еды.
- Предварительные условия. Пользователь должен получить доступ к системе в режиме онлайн с действительными учетными данными.
- Первичный актор. Клиент, заказывающий еду через Интернет и производящий оплату.
- Основной поток или основной сценарий. Клиент может изучить меню ресторанов и сделать заказ, исходя из удобства и предпочтений в еде.
- Пост-условие. Система отправляет уведомление о деталях заказа с указанием произведенных платежей.



=============== 9. Предугадывание ошибок (Error Guessing - EG) ==============

Предугадывание ошибки - это когда тестировщик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы "предугадать" при каких входных условиях система может выдать ошибку. Например, спецификация говорит: "пользователь должен ввести код". Тест аналитик, будет думать: "Что, если я не введу код?", "Что, если я введу неправильный код? ", и так далее. Это и есть предугадывание ошибки.
Тестировщик действует, исходя из своего опыта и навыков, пытаясь предугадать проблемные места в приложении. Поэтому успешность этой методики сильно зависит от опыта и скиллов, и глубины понимания тестируемого продукта.

Частыми ошибками в приложениях (следовательно, наиболее вероятными ошибками в тестируемом приложении) являются, например:

Ввод некорректных (невалидных) параметров и символов
Например, ввод пробела в “цифровые” поля, где это недопустимо
Ошибка-исключение null pointer exception
Деление на ноль
Превышение максимального количества передаваемых файлов
И подобные «типичные пользовательские» ошибки
Итак, цель предугадывания — найти ошибки, которые трудно “выловить” другими методиками черного ящика. Готовятся тест-кейсы, направленные на области наиболее вероятных ошибок; по возможности покрываются все проблемные места; но без избыточности.
Методика, разумеется, не является идеальной, способной обеспечить высокое качество — ведь она основана на интуиции, поэтому ограничена по умолчанию, зависит от умений и, главное, опытности QA-инженера. Она вовсе не гарантирует высокого покрытия, и должна сочетаться с другими методиками, дополнять их.

Что нужно, чтобы хорошо угадывать ошибки
- Интуиция тестировщика
- Его знание продукта
- Опыт прошлых проектов
- Чек-лист
- Знание типичных проблем с интерфейсом
- Идеальное знание общих принципов тестирования
- Результаты предыдущих тестов
- Характерные ошибки, случавшиеся ранее


-------- Пример 1 предугадывания ошибок --------
В приложении есть функция ввода номера телефона клиента, и он должен быть стандартной длины, то есть 10 цифр. Методика предугадывания ошибок в данном случае может проверить, например:

- Что случится, если ввести не цифру, а букву или пробел
- Если ввести только 8 цифр
- Если оставить поле пустым
- Если ввести не 10, а 12 цифр
- Если такие невалидные значения введены, и функция ведёт себя как ожидается — то есть показывает ошибку, она расценивается как не имеющая багов; в противном случае заводится баг, и функция передается разработчикам, чтобы те устранили баг.


-------- Пример 2 предугадывания ошибок --------
Рассмотрим сценарий, в котором вы тестируете функциональность перевода средств в банковском приложении. Есть поле, в которое нужно ввести сумму. Согласно требованиям, вы можете перевести любую сумму в диапазоне от 100 до 100000.
Если вы примените стандартные методы анализа граничных значений и эквивалентного разбиения, вы можете получить следующие значения для проверок: 99, 100, 101, 50000, 99999, 100000, 100001.
Однако опытный тестировщик сталкивался с тем, что несколько похожих приложений не обрабатывали случаи с отрицательным значением. Он использует этот опыт, чтобы создать сценарии поиска ошибок для текущего приложения.




=============== 10. Доменный анализ (Domain Analysis Testing) ==============

Практика показала, что в большинстве случаев использование только одной техники не даёт нужного результата.
Именно поэтому была придумана техника доменного тестирования (Анализа доменов).
Доменный анализ  — это техника основана на разбиении диапазона возможных значений переменной на поддиапазоны, с последующим выбором одного или нескольких значений из каждого домена для тестирования.
Доменное тестирование — это техника тестирования метода чёрного ящика, направленная на уменьшение количества тестов путём одновременной проверки множества различных позитивных значений. Данная техника базируется на одновременном использовании техник эквивалентного разбиения и анализа граничных значений.

Для проверки длины поля Username комбинацию этих техник можно представить так:

  (Invalid)   |   (Valid)     |    (Invalid)  
--------------|---------------|---------------
            2 | 3    11    20 | 21            


Тем самым мы проверили поведение на границах и для надёжности ещё убедились в том, что поле работает не только на границах, использовав среднее значение 11.

Но достаточно ли этого для проверки поля? Однозначно нет.
Мы должны определить какие ещё могут быть классы и какие у них граничные значения.
Например, у нас получились классы эквивалентности по следующим признакам (атрибутам значений):
1) Разное количество символов (допустимое, менше минимального, пустое поле, больше максимального);
2) Уникальность (уникальный, неуникальный);
3) Разный регистр (нижний, верхний, смешанный);
4) Разные символы (цифровые, алфавитный текст, разные языки, спецсимволы, разные кодировки);
5) Наличие пробелов (в начале, в середине, в конце).


Но на практике, многие позитивные проверки мы можем объединить.
Суть доменного тестирования не только в том, чтобы выбирать показательные значения при помощи двух техник, но ещё и одновременной проверке множества позитивных условий одновременно.
Например, мы можем сделать так:
1) Класс 1 - минмальное количество, верхний регистр, алфавитный текст, уникальное значение;
2) Класс 2 - среднее количество, цифры, уникальное значение;
3) Класс 3 - максимальное количество, смешанный регистр, разные языки, цифровые значения, алфавитный текст, спецсимволы, уникальное значение;
4) Класс 4 - неуникальное значение;
5) Класс 5 - пустое поле;
6) Класс 6 - больше максимального;
7) Класс 7 - разные кодировки;
8) Класс 8 - наличие пробелов.

Мы объединили значения из нескольких позитивных классов и если, например, в значении BatМэн2!@#$%^&*()-_= хотя бы одно из условий выполняться не будет (например ввод спецсимволов), то упадёт весь тест и мы быстро найдём ошибку.

Для того чтобы понять, какое условие вызвало ошибку, можно использовать следующий алгоритм:
1) Поделить упавшее значение на 2
2) Если оба значения не проходят, то каждое нужно ещё раз поделить на 2
3) Если в одном значении ошибка пропала, то оставшиеся делим на 4
Тем самым мы быстро определим, а что именно вызвало ошибку в нашем тесте.

Очевидно, что не все позитивные тесты мы можем объединить друг другом. Например, мы не можем одновременно использовать и минимальное и максимальное значение вместе.

Однако, негативные тесты ни в коем случае нельзя объединять друг с другом!
Представим, что мы проверяем вместе значение меньше минимального с добавлением пробела в начале » Bo». Мы предполагаем, что оба эти условия должны вызывать ошибку.
По итогу, если одно из условий по факту вызывает ошибку, а второе нет, то на экране мы увидим ошибку. И ложно подумаем, что тест был пройден успешно. А во втором условии у нас будет баг, который мы не обнаружим.
Именно поэтому негативные тесты нельзя объединять друг с другом.



=============== 11. Таблица принятия решений (Decision Table) ==============

Decision Table (таблица решений) — техника, помогающая наглядно изобразить комбинаторику условий из ТЗ.
Таблица принятия решений — инструмент тест-дизайна, или процесса создания тестов. Таблица помогает придумать, как и что тестировать в программном обеспечении, например на сайте или в приложении. Её можно использовать для проверки требований, собранных для разработки ПО, например проверять, что учтены все возможные варианты.
В тестировании таблица решений используется для того, чтобы на основе требований составить тест-кейсы. И ничего не забыть при сложных комбинациях входных условий! Ведь каждая строка или столбец таблицы → готовый тест-кейс.

Таблица принятия решений, как правило, разделяется на 4 квадранта:
Условия	  |  Варианты выполнения условий (Правила)
----------|----------------------------------------
Действия  |	 Статус тестирования

Условия (Conditions) — список возможных условий, критериев.
Правила (Rules), (Варианты выполнения действий (условий)) — комбинация из выполнения и/или невыполнения условий этого списка.
Действия (Actions) — список возможных действий.
Статус тестирования (Status) — указание надо или не надо выполнять соответствующее действие для каждой из комбинаций условий; статус проведения тестирования (passed, failed).


------- КАК ПРАВИЛЬНО СОЗДАВАТЬ ТАБЛИЦУ РЕШЕНИЙ -------
Ничего сложного, ведь мы оперируем исключительно графами по вертикали и горизонтали. Итак:
По горизонтали — тестировщик должен выписать полный перечень условий, которые влияют на итоговое поведение продукта. 
Ниже — непосредственно итог (результат) (action), который должен выполняться;
По вертикали — принятые правила (сумма условий), на основании которых стоит оперировать тестируемым продуктом.

То есть мы указываем значения условий и результата. В результатах (Actions) у нас может быть не только два значения (выаполнено/не выполнено; passed/failed), но и больше двух. 
Например, разная сумма выплат (200 руб, 100 руб, 50 руб, 10 руб) по страховке, в зависимости от выполнения
одного или нескольких указанных условий (стаж вождения, был в авариях или нет).


------- ВАРИАНТЫ ЗАПОЛНЕНИЯ ТАБЛИЦЫ -------
-> "X" или "пустая ячейка"
-> "True" или "False" ("T" или "F")
-> "1" или "0"
-> "V" или "X"
-> "V" или "пустая ячейка"

----- Пример 1 -----
Например у тестировщика есть страница с логином-паролем.

Имеем требования:
-> Пользователь должен залогиниться, вводя правильные User ID/Password.
-> Пользователь не должен залогиниться, если комбинация неправильная; выдается сообщение “Неверные данные”, если любое из двух значений неправильное (или пустое).

Глядя на требования, видим, что наша Таблица Решений будет состоять из:

- Двух условий: user_id и password
- Двух действий: Логин успешный; или Ошибка, выдается сообщение “Некорректные данные”
- Трех опций: Пустое; Правильное; Неправильное; (поле)


----- Пример 2 ------ 
Страховка на автомобиль (один результат)

Вы приходите в страховую компанию и заполняете анкету, где есть 2 вопроса:
-> Есть ли 5 лет стажа вождения?
-> Был ли в авариях?
Ответить можно либо да, либо нет.

Получается 2 условия по 2 возможных варианта, итого 4 варианта пересечения условий, 4 правила. На каждое правило свой результат:

--> Если у меня небольшой стаж и я часто бываю в авариях — придется заплатить по максимуму (200р), иначе страховать такого водителя будет невыгодно.
--> Если нет стажа, но нет аварий — плачу поменьше, но не сильно (100р). Знаете как бывает — первое время катаются очень осторожно, а потом начинают думать «да я царь и бог, не попаду в аварию». И понеслось...
--> Если я опытный водитель, но бываю в авариях — ценник еще чуть ниже (50р). Ведь бывать в авариях — это нормально. Иногда ты просто стоишь на светофоре, а в тебя влетает дурак, ну что тут поделаешь? Но если аварий мало, а опыта много — это хороший знак.
--> Если опытный, да еще и без аварий — меньше всего (10р). Очень аккуратный водитель, платить скорее всего не придется!

А теперь если то же самое записать в виде таблицы, получится очень компактный вариант представления зависимости поведения системы от комбинации условий.