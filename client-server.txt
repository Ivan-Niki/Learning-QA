
------------ Клиент-серверная архитектура ------------

Архитектура «клиент-сервер» — компьютерная система, в которой множество клиентов (компьютеров) запрашивают и получают данные на центральном сервере. В этой модели есть три компонента: отображение, логика, и данные.
Клиент — это аппаратный или программный компонент вычислительной системы, посылающий запросы серверу.
Программа, являющаяся клиентом, взаимодействует с сервером, используя определённый протокол. Она может запрашивать с сервера какие-либо данные, манипулировать данными непосредственно на сервере, запускать на сервере новые процессы и т.п.

Сервер (от англ. server — обслуживающий) — сетевой компьютер (устройство), обрабатывающий запросы от других компьютеров в локальной или глобальной сети. Как правило, сервер выделен из всей группы компьютеров, подключенных к единой сети, работает автономно, без участия человека, за исключением первичной настройки. Также под этим термином подразумевается программное обеспечение, обрабатывающее пользовательские запросы.

ТИПЫ СЕРВЕРОВ: веб-сервер, сервер приложения, прокси-сервер, почтовый сервер, файловый сервер,
виртуальный сервер, сервер баз данных.



Существует три базовых типа клиент-серверной архитектуры: 2-уровневая, 3-уровневая, и n-уровневая. 


--- Толстые и тонкие клиенты ---
Если обработка логики и данных осуществляется на стороне клиента, то клиентский (например) ноутбук называется толстым клиентом.
Если это обрабатывается на сервере (оставляя у пользователя только отображение результата), то его ноутбук можно назвать тонким клиентом.



------ Двухуровневая клиент-серверная архитектура --------

В такой архитектуре уровень презентации (отображения, представления) — находится на компьютере (смарфоне) клиента, а уровень логики и данных — на сервере.



------ Трехуровневая клиент-серверная архитектура --------

Если объем вычислений огромен, и большая часть их происходит на сервере, то логика и данные могут быть разнесены по двум отдельным уровням (уровень логики и уровень данных); так получается 3-уровневая архитектура.
Вся «логическая часть» отправленного запроса будет обрабатываться на одном уровне, а часть обработки данных, касающихся этого запроса — на другом уровне; после обработки «финальный» ответ будет отправлен клиенту «назад по цепочке».

       запрос                   запрос
Клиент -------> Уровень логики --------> Уровень данных
       <-------                <-------
         ответ                  ответ




------- Многоуровневая клиент-серверная архитектура --------

Если ИТ-система еще больше (уровня большой корпорации с миллионами пользователей), а обработка данных еще более сложная и объемная, то в такой ИТ-системе может быть еще больше уровней (условно n уровней); чаще всего вводится уровень кэширования между уровнями логики и данных, а также уровень балансировки нагрузки, и прокси-уровни (м.б. несколько) между «базовыми» уровнем клиента и уровнем обработки логики.
В многоуровневой архитектуре применяются кластеры серверов — когда приложение (уровень логики) находится не на одном, а сразу на нескольких серверах. Информация на таких серверах дублируется. В кластере может быть не 2 сервера, а 10, 15, сколько нужно, столько и ставим.
Если один сервер вышел из строя, то его подменяет другой. Это дает время, чтобы устранить неисправности сервера так, что пользователи и не заметят.
Еще кластеры используются, чтобы распределять нагрузку. Мы уже говорили, что сервер может отключиться от десятка миллионов одновременных запросов. Кластеры можно настроить так, чтобы при десяти миллионах запросов они ушли не на один сервер, а на разные.
Чтобы определить, на какой сервер послать запрос, используется балансировщик — сервис, который пропускает все запросы через себя и следит, чтобы серверы не перегружались.


Клиент --> Балансировщик нагрузки/или прокси --> Логика (несколько серверов) --> Кэширование --> Данные




------- Что такое кэш (cash) и куки (cookie) --------

1) Кэш — это память программы или устройства, в которой сохраняются временные или часто используемые файлы для быстрого доступа к ним. Это увеличивает скорость работы приложений и операционной системы.
2) Кэш – это часть места на жестком диске, предназначенная для хранения файлов браузера, которые, согласно оценкам браузера, могут быть использованы повторно. Без этой функции браузер работал бы медленнее, поскольку при открытии каждого веб-сайта должно было бы загружаться большое количество файлов с нуля, включая такие компоненты, как логотип сайта, фоновые изображения, шрифты, а также технические элементы, такие как CSS, HTML и JavaScript. В совокупности их количество может достигать десятков, сотен или даже тысяч файлов для одного веб-сайта. В кеше эти файлы хранятся локально, поэтому при будущих посещениях веб-сайты будут загружаться быстрее, что улучшит общее впечатление от работы в интернете.

Для примера рассмотрим кэш браузера. Это папка с файлами, которые браузер загрузил в память устройства. В файлах могут быть видео, музыка, изображения или скрипты с какого-то сайта. Когда вы в следующий раз вернётесь на сайт, то браузер не будет запрашивать эти файлы, а возьмёт их из кэша. Нужная вам страница загрузится быстрее.
Увидеть, как кэшируются файлы, можно при просмотре онлайн-видео. Пока вы смотрите видеоролик, он загружается в кэш вашего устройства. Если видео загрузится полностью, его можно будет досмотреть даже с отключённым интернетом.


----- Зачем чистить кэш? -----
Проблема может возникнуть, если на сервере страница обновится, а браузер продолжает подгружать старую версию из кэша. Веб-страницы могут отображаться некорректно в связи с тем, что в них были внесены изменения, а браузер продолжает использовать устаревшие данные из кэша. С накоплением кэша место на компьютере, пусть незначительно, но уменьшается.

----- Как почистить кэш? -----
Есть разные способы его очистки, но мы продолжим использовать «Инструменты разработчика». Переходим на интересующий веб-сайт, нажимаем F12, потом опять Application. 
Далее выбираем Clear storage и скроллим вниз. Смотрим, чтобы стояла галочка напротив Cashe storage и нажимаем кнопку Clear site Data. 
Обратите внимание, что тут же можно почистить сразу и куки, да и не только их.



Файлы cookie – это простые текстовые файлы, которые веб-сайт может хранить в браузере. Они предназначены для идентификации пользователей, хранения данных для входа на сайт и создания персонализированных веб-страниц, учитывающих индивидуальные предпочтения.

--> Cookie - это файлы, содержащие информацию в формате "ключ=значение", которые генерируются сервером при первом запросе, зашифровываются и отправляются в ответе. 
После этого куки отсылаются вместе с каждым последующим запросом на сервер. 
--> Значения в куках хранятся в виде зашифрованных строковых данных (ключ дешифровки есть только на сервере).
--> Cookie нужны бэк-энду, но клиент может получить к ним доступ через:
1) document.cookie;
2) F12 --> Application --> Storage --> Cookies --> выбрать сайт --> ПКМ - clear;

--> Cookie имеют срок годности (expires, max-age). 
Например: expires=Tue, 19 Jan 2038 03:14:07 GMT; max-age=3600 (expires определяет дату истечения срока действия куки, когда браузер удалит его автоматически; max-age определяет срок действия куки в секундах с текущего момента).
По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся автоматически при закрытии браузера. Такие куки называются сессионными («session cookies»).

--> Cookie ассоциируются с определенным доменом (vk.com, google.com, ok.ru и т.д.);
--> Cookie имеют отграничение в 3 Kb на сайт (домен);
--> Cookie запрещают доступ (чтение или запись) на клиенте. Для этого выставляется флаг - HttpOnly (только на сервере).
--> Cookie запрещают доступ на обычном протоколе HTTP. Для этого выставляется флаг Secure. После этого к cookie можно получить доступ только на HTTPS.
По умолчанию куки, установленные сайтом http://site.com, также будут доступны на сайте https://site.com и наоборот.
То есть, куки, по умолчанию, опираются на доменное имя, они не обращают внимания на протоколы.
С этой настройкой, если куки будет установлено на сайте https://site.com, то оно не будет доступно на том же сайте с протоколом HTTP, как http://site.com. Таким образом, если в куки хранится конфиденциальная информация, которую не следует передавать по незашифрованному протоколу HTTP, то нужно установить этот флаг.

---------- Какие основные задачи выполняют куки-файлы и в чем они помогают пользователям: -------

- Аутентификация — в процессе участвуют cookie-файлы, где находятся данные вашего логина, email и пароля. При повторном входе соответствующие поля заполнятся автоматически. Кроме того, они позволяют вам всегда оставаться «в аккаунте» и не попадать на страницу авторизации при обновлении страницы. Например, благодаря cookie при повторном входе в социальную сеть вы сразу видите свою ленту.
- Сохранение настроек и данных — куки фиксируют, какие действия вы совершали на сайте и какие персональные настройки выстраивали (например, язык, валюта, размер шрифта). Например, на сайте по поиску авиабилетов сохраняется информация о языке, валюте, планируемых локациях, дате, а также выбранный билет в корзине. При перезагрузке сайта или выходе из него все фильтры и неоплаченные товары сохраняются.
- Статистика о пользователе — задавая настройки или кликая на понравившийся товар, вы неосознанно рассказываете о ваших интересах и предпочтениях. Куки отмечают эту информацию и помогают персонализировать ваш последующий поиск.

Также куки умеют запоминать:
- текст, который мы вводили на сайте раньше;
- IP-адрес и местоположение;
- товары, которые мы просматривали или добавили в корзину;
- версию ОС и браузера;
- клики и переходы;


---------- Типы cookie-файлов ----------

--> Постоянные куки
Основной вид куков, которые запоминают ваши действия и передаются при каждом посещении сайта. Именно они сохраняют все ваши данные в долгосрочной перспективе, однако с определенным сроком годности. Пользователь может очистить их сам, когда захочет. Чуть позже мы расскажем, как очистить куки сайта.
--> Временные куки
Куки, которые сопровождают посетителя сайта только на протяжении сессии. После закрытия сайта данный тип куков удаляется самостоятельно.
--> Third-party cookies, или сторонние куки
В отличие от прошлых двух типов, данный вид куков не сохраняется на вашем устройстве. Если на сайте размещен кликабельный материал со сторонних сайтов вроде баннеров или на сайте встроены браузерные скрипты (например, Google Analytics и т.п.), то информация с вашими действиями уходят к владельцам этого контента. Этими видами куков пользуются маркетологи, которые проводят анализ посещаемости и количества кликов.
--> и др.


Файлы cookie - cлужебные файлы, хранящие настройки сайтов, которые пользователи посещали. Самая распространённая функция - сохранение паролей, которая позволяет не вводить комбинацию логин + пароль каждый раз при входе на сайт.  В зависимости от настроек, каждый браузер хранит информацию о паролях разное время.
Также куки могут среагировать, если пользователь, например, перейдет по ссылке с какого-либо баннера. В дальнейшем информация, сохраненная в куки, может влиять на виды рекламных баннеров, которые отображаются у пользователя.



Вот несколько примеров использования куки на практике:
1. Авторизация на сайте. Как известно большинство сайтов имеют авторизацию (ввод пароля, логина, телефона, почты и т. п.). Cookie могут применяться сервером для опознания ранее аутентифицированных пользователей.
2. Корзина в интернет-магазинах. Если не использовать куки, при выборе товара и переходе на новую страницу товар может исчезнуть.
3. Настройки. К примеру, вы выставили нужные настройки региона, языка и т. д. Без куки они могут сброситься и вернуться в статус значений по умолчанию.


----- Зачем  чистить cookie? -----
Воспользовавшись компьютером, посторонний человек может посещать форумы и сайты под именем владельца компьютера. Большое количество сохраняемых кук ведет к сокращению места на жестком диске. Пользуясь куки, можно проследить историю перемещений в сети, что нежелательно с точки зрения конфиденциальности.

----- Как почистить кэш и куки? -----
Куки можно почистить в инструментах разработчика. Для Google Chrome нажмите F12, потом вкладку Application (вы должны находиться на странице сайта, куки которого собрались чистить). 
То есть надо будет выбрать адрес сайта под строкой Cookie, нажать правую кнопку мыши, а потом «Clear».



----- В чем разница между кэшем и файлами cookie? -----

И кеш, и файлы cookie предназначены для повышения производительности веб-сайтов и удобства работы пользователей за счет хранения данных на устройствах. Однако между ними есть следующие различия:

Файлы cookie используются для хранения информации о различных аспектах работы пользователя, а кеш используется для ускорения загрузки веб-страниц.
В файлах cookie хранится такая информация, как пользовательские настройки, а в кеше хранятся файлы ресурсов: аудио, видео или флэш-файлы.
Срок хранения файлов cookie обычно ограничен, а кеш хранится на устройстве пользователя до тех пор, пока не будет удален вручную.





---------------- ЧТО ТАКОЕ API ----------------

API (англ. Application Programming Interface — программный интерфейс приложения) — это набор способов и правил, по которым различные программы общаются между собой и обмениваются данными.
Все эти взаимодействия происходят с помощью функций, классов, методов, структур, а иногда констант одной программы, к которой обращаются другие. Это основной принцип работы API.

----- Где используется API -----

API позволяет интегрировать в программу функции, которые уже реализованы в другом приложении. Например, добавить на свой сайт «Яндекс.Карты» или подключить сервис email-рассылок к собственной СRМ-системе. 
То есть вам не нужно разрабатывать собственное ПО для решения типовой задачи, можно использовать готовый инструмент. Это позволит быстро внедрить функцию в проект и сэкономить деньги.

Допустим, вы покупаете билет в кино с помощью банковской карты. Во время покупки терминал обращается к API банка, который выпустил вашу карту, и отправляет запрос на оплату. А если вы заказываете такси через приложение, оно обращается к платёжной системе тоже через API.

----- Как работает API -----
По сути, интерфейс API можно назвать посредником двух приложений. В нем протекают процессы, позволяющие другим сервисам осуществлять обмен данными и выполнять команды, которые связаны с обеими приложениями. Внутреннее содержимое программ при этом оказывается скрытым.

Опишем процесс работы с API на примере:
-> 1. Разработчик пишет собственную программу, операционную систему или функцию.
-> 2. Для этого он разрабатывает API — особенный набор правил, на основе которых другие программисты смогут пользоваться его разработкой для собственных задач.
-> 3. Другой программист получает данный API. Доступ можно получить по запросу или на публичной платформе.
-> 4. Он вызывает API внутри собственного сервиса и использует его возможности.

Знать, как работает функция, которую вызывает программист, необязательно. В ней может содержаться огромное количество информации, но с интерфейсом, который предоставляет API, получить к ней доступ можно будет с помощью одной команды.


------ Примеры API ------

-> Картографические сервисы. 
Компании размещают на сайте или в приложении карту от «Яндекс» или Google. 
Сервис позволяет отметить филиалы, добавить изображения или комментарии к меткам, указать адрес для доставки.

-> Агрегаторы. 
Сайты, которые собирают информацию из нескольких источников, чаще всего используют для этого API. Например, сервисы авиабилетов, агрегаторы новостей, площадки для продажи товаров, бронирования отелей.

-> Сервисы оплаты. 
Когда покупатель использует карту, терминал оплаты обращается к программному интерфейсу банка. 
Если вы оплачиваете такси, доставку еды или товары в приложении, оно также подключается к платежной системе через API.

-> Авторизация через соцсети. 
Формы для быстрой регистрации и авторизации через социальные сети встречаются на многих ресурсах. Пользователю просто и удобно создать учетную запись на сайте в два клика, а не заполнять каждый раз однотипную форму.

-> Приложения Погоды
Существуют сервисы, напрямую работающие с метеорологическими станциями. 
Такие приложения автоматически запрашивают данные о погоде в определенной локации, а API обрабатывает его и связывает со спутником. 
Благодаря этому клиент всегда имеет доступ к достоверной информации.

-> Переводчики
К примеру, переводчик, встроенный в Google Chrome, а также Яндекс Переводчик дают разработчикам приложений доступ к своим API. Это позволяет подключить их интерфейс к собственному сервису для автоматического перевода страниц.




----- Типы API -----
Существует несколько типов API. Некоторые из них более распространены, чем другие. 
Рассмотрим наиболее популярные типы API.

---> REST API
REST API (Representational State Transfer API) — это наиболее распространённый тип API. 
Разработчики используют его для создания веб-сервисов, которые могут обмениваться данными с другими приложениями и сервисами через интернет.
REST API основан на HTTP-протоколе и использует запросы HTTP для обмена данными между клиентом и сервером. 
Для каждого запроса клиент должен указать метод (GET, POST, PUT, DELETE), URL-адрес и параметры запроса.


---> SOAP API
SOAP API (Simple Object Access Protocol API) — это ещё один распространённый тип API. Разработчики используют его для обмена данными между приложениями, работающими на разных платформах, например, между .NET и Java.
SOAP API основан на XML и использует SOAP-протокол для обмена данными между клиентом и сервером. Каждый запрос SOAP содержит заголовок и тело сообщения, которое может содержать данные, методы и параметры запроса.

---> WebSocket API
WebSocket API — это тип API, который используется для создания постоянного соединения между клиентом и сервером. 
Он позволяет клиенту и серверу передавать данные в режиме реального времени, без необходимости постоянно отправлять запросы.
WebSocket API основан на WebSocket-протоколе и использует двустороннюю связь между клиентом и сервером. 
Это позволяет серверу отправлять данные клиенту в режиме реального времени, что делает этот тип API особенно полезным для приложений, которые требуют быстрой передачи данных. 
Например, передача видеопотока в видеохостинге или сервисе облачного гейминга.

---> GraphQL API
GraphQL API — это относительно новый тип API, который появился в 2015 году. 
Разработчики используют его для создания гибких и эффективных веб-сервисов, которые могут быстро и точно получать необходимые данные.
GraphQL API основан на запросах, которые отправляются клиентом серверу в формате GraphQL. 
Каждый запрос содержит только те данные, которые нужны клиенту, что делает этот тип API более быстрым и эффективным, чем другие.






--------------------- Коды состояния HTTP ---------------------

Обозначим ключевые термины:

--> Клиент — это программное или аппаратное обеспечение, имеющее подключение к интернету и запрашивающее некоторую функцию или данные у сервера.
--> Сервер — это компьютер, на котором хранятся данные. Он выполняет ряд служебных функций для других компьютеров сети, принимает клиентские запросы и отвечает на них.

Существует 5 категорий серверных ответов. Класс состояния можно определить по первой цифре.

1** — информационные сообщения, передача данных (не ошибка).
2** — успешный запрос (не ошибка).
3** — перенаправления на другой адрес (не ошибка).
4** — клиентские ошибки.
Код состояния HTTP - часть первой строки ответа сервера, который информирует клиента о результате запроса. Состоит он из трех цифр, первая из которых указывает на класс состояния. За цифрами идет фраза, которая объясняет причину ответа.
5** — серверные ошибки. Причина технической ошибки со стороны сервера указывается в коротком текстовом описании после кода. Например, ошибка 500 — это внутренние сбои, реже — высокая нагрузка на сервер.



-------- 1xx - информационные коды --------

-> 100	Continue (Продолжай)
Сервер удовлетворён начальными сведениями о запросе, и клиент может продолжать.

-> 101	Switching Protocols	(Переключение протоколов)
Клиент, пославший запрос, предлагает перейти на более подходящий для указанного ресурса протокол.

-> 102 Processing (Обработка)
Поскольку запрос WebDAV (протокол передачи), кроме основного запроса может включать и ряд других подзапросов, подразумевая также и файловые операции, то для его выполнения может потребоваться больше времени.

-> 103	Checkpoint	(Контрольная точка)
Используется в запросах с возможностью продолжения для возобновления после прерывания запросов POST или PUT.




-------- 2xx - Success (Успех) --------

-> 200	OK
OK — успешный запрос. HTTP запрос успешно обработан.

-> 201	Created (Создано)
В результате успешного выполнения запроса был создан новый ресурс. 
Этот код обычно присылается в ответ на запрос PUT.

-> 202	Accepted (Принято)
Запрос был принят в обработку, но обработка еще не завершена.

-> 203 Non-Authoritative Information (Недостоверная/неавторитетная информация)
Запрос был успешно обработан (аналогично ответу 200), но в этом случае передаваемая информация была взята не из первичного источника (например, из резервной копии или другого сервера) и может быть неактуальной.

-> 204 No Content ("Нет содержимого")
Запрос был успешно обработан, но не вернул какой-либо контент. 
Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются. Клиент может использовать их для обновления кешированных заголовков полученных ранее для этого ресурса.

-> 205 Reset Content ("Сбросить содержимое")
Запрос был обработан, но не вернул контент. При этом требуется сброс введенных данных клиентом.
Этот код присылается, когда запрос обработан, чтобы сообщить клиенту, что необходимо сбросить отображение документа, который прислал этот запрос.
Аутентификация при помощи форм может быть успешной или неудачной. При неудачном выполнении обычно повторно отображается форма с очищенными полями.
И как раз для этого предназначен код состояния 205:
"HTTP-код состояния 205 Reset Content сообщает клиенту, что нужно сбросить визуализацию документа, то есть, например, очистить содержимое формы, сбросить состояние canvas или обновить UI". -- [Веб-документация MDN]

-> 206	Partial Content ("Частичное содержимое")
Сервер возвращает только часть контента, которая соответствует заголовку, отправленному клиентом. 
В основном его используют расширенные инструменты кэширования. 
Такое бывает, когда пользователь хочет получить лишь небольшую часть контента страницы, а сервер в своем ответе предоставляет данные только для этой части страницы.

-> 207 Multi-Status (Мультистатус)
Сервер параллельно предоставляет результаты нескольких независимых операций, которые включаются в тело сообщения в виде XML-документа.




-------- 3xx: Redirection - Редирект (перенаправление) --------

Коды состояния HTTP 3xx указывают на перенаправление. Когда пользователь или поисковые системы сталкиваются с кодом состояния 3xx, они будут перенаправлены на URL, отличный от исходного. Если SEO важен для успеха вашего бизнеса, тогда вы должны узнать об этих кодах и о том, как их правильно использовать.

-> 300 Multiple Choices ("Множественный выбор")
Выбор из нескольких вариантов
Сервер передаёт с сообщением список из нескольких возможных вариантов перенаправления альтернатив (максимум 5 вариантов). Клиент может выбрать один из них.

-> 301 Moved Permanently ("Перемещён на постоянной основе")
Этот код ответа значит, что URL запрашиваемого ресурса был изменён. 
Возможно, новый URL будет предоставлен в ответе.

-> 302 Found ("Найдено")
Найдено/временно перемещено
Запрашиваемая страница была найдена / временно перенесена на другой URL.
Этот код ответа значит, что запрошенный ресурс временно изменён. Новые изменения в URI могут быть доступны в будущем. Таким образом, этот URI, должен быть использован клиентом в будущих запросах.

-> 303 See Other ("Смотрите другое")
Просмотр других ресурсов
Этот код ответа присылается, чтобы направлять клиента для получения запрашиваемого ресурса в другой URI с запросом GET.

-> 304 Not Modified ("Не модифицировано")
Используется для кеширования. Это код ответа значит, что запрошенный ресурс не был изменён. 
Таким образом, клиент может продолжать использовать кешированную версию ответа.

-> 305 Use Proxy ("Использовать прокси")
Это означает, что запрошенный ресурс должен быть доступен через прокси. 
Этот код ответа в основном не поддерживается из соображений безопасности.

-> 306 Switch Proxy ("Переключить прокси")
Изначально он означал, что «последующие запросы должны использовать указанный прокси», но в настоящее время не используется.

-> 307 Temporary Redirect ("Временное перенаправление")
Сервер отправил этот ответ, чтобы клиент получил запрошенный ресурс на другой URL-адрес с тем же методом, который использовал предыдущий запрос. 
Данный код имеет ту же семантику, что код ответа 302 Found, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: 
если в первом запросе использовался POST, то во втором запросе также должен использоваться POST.




-------- 4xx: Client Error (Ошибка клиента) --------

Коды состояния 4xx являются ошибками клиента. Например: страница не найдена, или что-то не так с запросом. 
Что-то, что происходит на стороне клиента, является проблемой. Это может быть неправильный формат данных, 
несанкционированный доступ или ошибка в запросе.

-> 400 Bad Request ("Плохой запрос")
Запрос не может быть обработан, поскольку содержит синтаксическую ошибку.
Клиент отправляет запрос с неполными данными, плохо построенными данными или недопустимыми данными.
Ошибка возникает в случае, если браузер клиента отправляет некорректный запрос серверу. 
Это может быть синтаксическая ошибка. Например, в запросе отсутствовали символы завершения строки.

-> 401 Unauthorized ("Не авторизован")
Запрос обрабатывается, но доступ к запрашиваемому ресурсу не предоставляется, поскольку клиент не авторизован.
Он имеет отношение к запросу ресурса, который нуждается в авторизации. 
Код 401 информирует, что предварительную авторизацию отклонили, поскольку переданные пользовательские данные были неверные. Когда он отображается? 
В случаях, если пользователь делает запрос и использует при этом некорректные входные данные для авторизации (среди них, логин и пароль).

-> 402 Payment Required ("Необходима оплата")
Это нестандартный HTTP-статус. Он означает, что запрос не может быть выполнен, пока пользователь не произведет оплату. Код используется в платных пользовательских сервисах, а не в хостинговых провайдерах.
Этот код ответа зарезервирован для будущего использования. Первоначальная цель для создания этого кода была в использовании его для цифровых платёжных систем(на данный момент не используется).


-> 403 Forbidden ("Запрещено")
Запрет доступа к запрашиваемой странице. Он связан с тем, что у пользователя нет прав. 
Доступ может быть ограничен для определенных IP или в случае, если неавторизованный клиент пытается открыть файлы в системной папке. Этот код встречается, если сервер обнаружил вредоносные данные.
Пользователь пробует добиться доступа к веб-ресурсу, на который у него нет прав, а авторизация здесь никак не может помочь.
Этот код используется, когда сервер может понять запрос, но не разрешает выполнить его, поскольку у клиента имеются ограничения доступа к текущему разделу. 
Обычно такое наблюдается, если веб-ресурс не предназначен для открытого доступа.


-> 404 Not Found ("Не найден")
Искомый ресурс невозможно найти, но в будущем – когда он может появиться там – к нему можно получить доступ. 
Также здесь разрешаются все следующие обращения от клиента. 
Но в большом количестве таких случаев используется код редиректа класса 3xx, и пользователь перенаправляется на альтернативный ресурс или местоположение.
Когда демонстрируется этот код? Довольно часто, особенно если страницу удалили или переместили. 
Часто в таких случаях сервер в автоматическом режиме генерирует доступную страницу с ошибкой 404.
Это один из самых распространенных кодов ошибки HTTP клиента. 
Сервер дает ответ, что страница не найдена по данному URL. Например, страница перенесена на другой адрес. 
Не стоит путать код 404 с ошибкой «Сервер не найден». В данном случае клиент в состоянии общаться с сервером, но данных по его запросу нет.


-> 405 Method Not Allowed ("Метод не разрешён")
"Метод не разрешён". Сервер знает о запрашиваемом методе, но он был деактивирован и не может быть использован. 
Метод, посредством которого осуществляется запрос к ресурсу, является недоступным. 
Иными словами, появляется ошибка при попытке использовать функцию в формате GET, тогда как требуется ввод данных через метод POST (либо с помощью метода PUT с веб-документами только для чтения).
Сервер сообщает, что используемый метод не может применяться на данном ресурсе. Он предложит доступные методы в заголовке Allow.


-> 406 Not Acceptable ("Недопустимо" / Не принимается)
Запрашиваемый ресурс имеет возможность генерировать только тот контент, который не может использоваться в Accept-хедерах самого запроса. 
Браузер может обеспечить сервер характеристиками данных, которые будут приниматься из сервера.
В каких случаях такой код может быть использован? В ситуациях, когда форма файла ресурса, который запрашивается не подходит под формат, доступный для распознавания пользователем. 
Речь здесь идет прежде всего о языке программирования, а не о английском!
Этот код ошибки указывает, что запрашиваемый контент не может быть распознан из-за кодировки, метода сжатия и других причин.


-> 407 Proxy Authentication Required ("Недопустимо" / Не принимается)
Этот код ответа аналогичен коду 401 за исключением того, что аутентификация требуется для прокси-сервера.


-> 408	Request Timeout ("Тайм-аут запроса" / Время ожидания истекло)
Запрос клиента к серверу занял слишком много времени.
«Истекло время ожидания ответа на запрос». Сервер не получил запрос полностью в течение максимально допустимого для этого времени. Такой код может возникнуть при передаче данных большого объёма методом PUT или POST.


-> 409 Conflict ("Конфликт")
Запрос не может быть обработан по причине конфликта с другим запросом или конфигурацией сервера.
Сервер не смог обработать запрос из-за того что содержимое этого запроса вступило в конфликт с параметрами сервера. Такое может случиться, если два клиента одновременно пытаются изменить ресурс при помощи метода PUT.

-> 410 Gone ("Исчез" / Удалено)
Запрос не может быть обработан, потому что ресурс был удалён. Новое расположение ресурса при этом неизвестно.
Доступный по указанному URL раньше был доступен, но был удалён или недоступен.


-> 411 Length Required ("Требуется значение заголовка Content-Length")
Сервер отказывается обрабатывать запрос, пока в его заголовках не будет указано значение в поле Content-Length.
Длина контента не определена, и сервер не принимает запрос без этого. Повторный запрос должен содержать заголовок "Content-Length".


-> 412 Precondition Failed ("Невыполнимые условия запроса")
Клиент указал в своих заголовках условия, которые сервер не может выполнить.
Сервер не может обработать запрос, потому что в его заголовках указано условие, которое не может быть выполнено.


-> 413 Request Entity Too Large ("Слишком большой запрос" / "Слишком большое тело запроса")
Тело запроса превышает максимально допустимый размер, который сервер может принять.
Код 413 отображается в случаях, когда сервер отказывается обрабатывать запрос, потому что тело запроса слишком велико.
Когда этот код может применяться? При использовании метода POST с контентом, который больше по объему, чем сервер, способен обработать.


-> 414	Request-URI Too Long ("Слишком длинный URI")
URI превышает максимально допустимую длину. Такое может случиться, если выбран неправильный метод (GET вместо POST).
У веб-сервера есть ограничение длины для интерпретации, а запрашиваемый URL длиннее установленных рамок. Чтобы избежать возникновения этого кода ошибки HTTP запросов, следует использовать метод GET, а не POST.


-> 415 Unsupported Media-Type ("Неподдерживаемый медиа формат данных")
Сервер отказывается обработать запрос, потому что его содержимое содержит данные в недопустимом для такого метода формате.
Когда отображается такой код? Когда в запросе не указываются какие-либо типы носителей, поддерживаемые ресурсом или сервером. 
Например, пользователь запрашивает изображение в расширении, которое не поддерживается веб-сервером. 
Сервер знает, что запрашивалось, но не понимает формат, в котором хотели получить ресурс.


-> 416 Requested Range Not Satisfiable ("Диапазон не может быть выполнен")
В поле Range указан недопустимый для ресурса диапазон.
Этот ответ пользователь получает, когда он запрашивает часть ресурса, но в то же время этот фрагмент не может быть предоставлен.
Когда такой статус может применяться? Когда сервер запрашивает байты XXX-YYY ресурса, но ресурс немного меньше, чем указано при обращении


-> 417 Expectation Failed ("Недопустимое значение поля Expect" Ошибка ожидания)
Сервер не может выполнить условие в поле Expect в заголовках запроса.


-> 418 I’m a teapot ("Я чайник")
Сообщение, которое должен отправлять чайник для заварки чая, если на нём пытаются заварить кофе. 
Этот код ошибки был введён в качестве первоапрельской шутки в 1998 году.
Этот код был создан в 1998 году как одна из традиционных шуток на первое апреля IETF, в RFC 2324, 
как Hyper Text Coffee Pot Control Protocol и вряд ли он когда-нибудь будет обрабатываться современными HTTP-серверами.



-> 422 Unprocessable Entity ("Необрабатываемый запрос"). 
Синтаксис запроса правильный, но из-за логической ошибки сервер не может его выполнить. Такой код ошибки может возникнуть, если запрос содержит XML-документ с логической ошибкой.


-> 423 Locked ("Заблокировано"). 
Запрашиваемый ресурс заблокирован для запросов с таким методом.
Страница, которую запрашивает пользователь, заблокирована от применения указанного метода. Возможен следующий вариант решения проблемы: перезагрузка роутера и компьютера и использование статистического IP.


-> 424 Failed Dependency ("Невыполненная зависимость"). 
Сервер не смог выполнить запрос, потому что запрашиваемое в нём действие зависело от другого действия, и оно не сработало.
Выполнение текущего запроса напрямую зависит от успешности другой операции, и если она не будет правильно завершена, то вся обработка запроса остановится.


-> 426 Upgrade Required — ("Необходимо обновить протокол"). 
Сервер отказывается обрабатывать запрос, используя текущий протокол, но может сделать это после перехода на его другую версию. 
Сервер ОБЯЗАН указать в заголовках ответа требуемую версию протокола в поле Upgrade.


-> 429 Too Many Requests ("Слишком много запросов")
Этот код ошибок HTTP возникает, когда превышен лимит отправляемых пользователем запросов за короткий промежуток времени. Это делается, прежде всего, из соображений безопасности.





-------- 5xx: Server Error (Ошибки сервера) --------

Коды 5xx выделены для случаев неудачной работы на стороне сервера.
Эти ответы сервера часто отображаются, когда запросы пользователя не могут быть обработаны сервером по той или иной причине. Сервер должен иметь специальное сообщение для браузера, которое должно отображаться пользователю – оно уведомляет, что сервер (по какому-либо поводу) не в состоянии произвести обработку запроса.


-> 500 Internal Server Error ("Внутренняя ошибка сервера")
Сервер столкнулся с непредвиденной ошибкой во время обработки запроса.
Ошибка 500 говорит о том, что сервер не может обработать запрос к сайту, на странице которого вы находитесь. 
При этом браузер не может точно сообщить, что именно пошло не так.


-> 501 Not Implemented ("Не поддерживается")
Сервер либо не понимает метод запроса, либо не поддерживает инструкции, нужные, чтобы обработать обращение.
Вы можете столкнуться с указанным кодом 501, когда сервер не имеет поддержки стандартных протоколов запросов, среди которых GET, OPTIONS, HEAD, POST и т.д.
Ошибка 501 сообщает, что метод запроса сервером не поддерживается и его невозможно корректно обработать.
В ряде случаев в теле ошибки может быть указано: «Отправьте запрос позднее. Возможно, необходимая функция будет доступна».


-> 502 Bad Gateway ("Плохой шлюз" / Ошибка шлюза)
Пользователь увидит 502 код, если сервер, работает в качестве шлюза или прокси-сервера, и он получил недопустимый ответ от сервера верхнего уровня.
Когда используется подобный код? Обычно, когда сервер высшего уровня и прокси / шлюз не согласованы с протоколами, представленными в обращении. Как результат появляется ошибка обмена данных.
Такая ошибка отправляется в случае недействительного ответа от вышестоящего сервера. Основная причина — несогласованные протоколы сервера и посредника.


-> 503 Service Unavailable ("Сервис недоступен")
Сервер не доступен в данный момент (перегружен, отключен, на техническом обслуживании).
Код 503 означает, что возникли технические причины, из-за которых сервер на определенное время не способен обработать набор данных.
Его допустимо использовать в случаях, когда на сайт есть повышенный спрос, но у сервера нет возможности обрабатывать все входящие запросы.


-> 504 Gateway Timeout ("Шлюз не отвечает" / Тайм-аут шлюза)
Это код ошибки HTTP сервера является аналогом статуса 408. 
Сервер действует как шлюз и не получил ответ от вышестоящего сервера в обозначенное в настройках время.


-> 505 HTTP Version Not Supported ("Версия HTTP не поддерживается")
Сервер не поддерживает версию HTTP, которая указана в заголовках запроса.
Этот код аналогичен 426. Он сообщает, что сервер не поддерживает версию протокола HTTP, который используется клиентом. Это случается, если используется устаревший формат HTTP-протокола. Решением проблемы будет установка одной версии.


-> 507 Insufficient Storage — ("Недостаточно места"). 
Сервер не может выполнить запрос, потому что на нём недостаточно свободного места, чтобы сохранить необходимые для выполнения запроса данные.
Ошибка 507 имеет место, когда сервер не может разместить данные, поскольку для текущего запроса недостаточно пространства.
Этот код может быть применен, когда сервер загружен в полном объеме, а пользователь запрашивает ресурс, который уже имеется в наличии. 
Трудность здесь заключается в том, что на сервере нет места для хранения отправленных в запросе данных, чтобы отправить запрашиваемый ресурс.


-> 510 Not Extended ("Нет расширения")
У сервера отсутствует расширение, которое пользователь запрашивает. 
Список доступных расширений прописывается в теле ошибки.


-> 511 Network Authentication Required ("Требуется аутентификация сети")
Для получения доступа к сети, клиент должен пройти аутентификацию. 
Ошибка генерируется сервером-посредником, к примеру, сервером интернет-провайдера, если нужно ввести пароль для получения доступа к сети через платную точку доступа.
Этот статус-код демонстрируется, если клиенту следует сначала авторизоваться в сети, к примеру, необходимо ввести пароль для платного доступа в сеть Интернет.




================== МОДЕЛЬ TCP/IP ===================

Что такое TCP/IP
Модель TCP/IP — это стек протоколов, которые задают правила передачи данных по Сети. Так как бал здесь правят протоколы TCP и IP, в честь них и назвали всю модель.

TCP (Transmission Control Protocol) отвечает за обмен данными. Он управляет их отправкой и следит за тем, чтобы они дошли до получателя в целости. У TCP есть свои гарантии, что всё пройдёт успешно, — о них чуть позже.

IP (Internet Protocol) отвечает за адресацию. Его задача — связывать друг с другом устройства и нарезать данные на пакеты для удобной отправки. Чтобы протокол мог быстро найти дорогу от одного компьютера к другому, придумали IP-адреса — уникальные идентификаторы, которые есть у каждого устройства в Сети.

Эти два протокола работают в связке: IP строит маршрут, а TCP контролирует, чтобы всё передавалось правильно. Условно их можно сравнить с тандемом Шерлока и Ватсона в бессмертной классике Дойля: первый решает проблему, а второй следит, чтобы тот не наделал глупостей и случайно не упал в Рейхенбахский водопад.




--------- Из каких уровней состоит TCP/IP ----------

Пора окунуться в детали и узнать, как модель TCP/IP устроена изнутри. Глобально она делится на четыре уровня:

-> канальный уровень — отвечает за взаимодействие по сетевому оборудованию, например по Ethernet-кабелю или Wi-Fi;
-> межсетевой уровень — помогает отдельным сетям общаться друг с другом;
-> транспортный уровень — отвечает за передачу данных между устройствами, например, по протоколам TCP и UDP;
-> прикладной уровень — помогает приложениям общаться друг с другом с помощью интерфейсов или API.

На каждом уровне есть свои протоколы, которые обеспечивают надёжность передачи данных между компьютерами в Сети.
Всего модель TCP/IP поддерживает сотни разных протоколов.



-------- Канальный уровень / Уровень сетевых интерфейсов (Network Access layer) ---------

Самый нижний, уровень сетевых интерфейсов, обеспечивает взаимодействие с сетевыми технологиями (Ethernet, Wi-Fi и т.д.). Это объединение функций канального и физического уровней OSI.
Для чего нужен: устанавливать физическое соединение между устройствами в локальной сети с помощью радиоволн и проводов.

Примеры протоколов: Ethernet, Wi-Fi, Bluetooth.

Как работает: данные делятся на небольшие кусочки (фреймы) и передаются между устройствами. Каждый фрейм содержит часть передаваемой информации и служебные данные.
Чтобы понять, куда отправлять фреймы, используют адресацию канального уровня — MAC-адреса. Это уникальные физические адреса устройств — по ним протоколы канального уровня определяют отправителей и получателей.

___________________________________
 MAC-адрес  |  MAC-адрес | Данные  |  <------ Фрейм
оптравителя | получателя |         |
-----------------------------------

Ещё одна важная задача канального уровня — проверять, что данные передаются безошибочно. Для этого протоколы используют свои средства проверки:
Если возникла ошибка, устройство отправляет фрейм обратно, а второе устройство передаёт его ещё раз.
Если всё прошло удачно, то фрейм передаётся на следующий уровень для обработки.



--------- Межсетевой (сетевой) уровень (Internet layer) ---------

Для чего нужен: строить маршруты между устройствами по всему интернету — этот процесс называется маршрутизацией.
Примеры протоколов: IP, ICMP, ARP, DHCP*.
* - иногда его относят к прикладному уровню).
- DHCP (Dynamic Host Configuration Protocol) - служит для назначения IP-адреса клиенту.

Как работает: IP-протокол вычисляет местонахождение устройств по их IP-адресам, а также строит до них кратчайшие пути и делит данные на пакеты.
Чтобы определить, где находится получатель и как построить путь к нему, IP обращается к системе DNS — она знает IP-адреса всех устройств в интернете.

Когда адрес получен, передаваемый файл разбивается на небольшие части — пакеты. Они содержат фрагменты данных и служебную информацию, например IP-адреса отправителя и получателя.
___________________________________
 IP-адрес   |  IP-адрес  | Данные  |  <------ Пакет
оптравителя | получателя |         |
-----------------------------------

После этого начинается передача пакетов по маршрутизаторам и коммутаторам. Но процессом отправки занимается уже следующий уровень — транспортный.

Межсетевой (иногда называют "сетевой") уровень отвечает за объединение локальных сетей в глобальную. 
И сетевой уровень также отвечает за адресацию хостов, упаковку и функции маршрутизации. 
Основными протоколами сетевого уровня являются IP, протокол разрешения адресов (ARP), протокол управляющих сообщений Интернета (ICMP) и протокол управления группами Интернета (IGMP). 
IP - это маршрутизируемый протокол, отвечающий за IP-адресацию, маршрутизацию и фрагментацию и повторную сборку пакетов. 
ARP отвечает за обнаружение адреса уровня сетевого доступа, такого как адрес аппаратных средств, связанный с данным доступом к Интернет-уровню. 
ICMP отвечает за предоставление диагностических функций и отчетов об ошибках из-за неудачной доставки IP-пакетов. 
IGMP отвечает за управление многоадресными группами IP. На этом уровне IP добавляет заголовок к пакетам, который известен как IP-адрес. 
Сейчас есть IPv4 (32-битный) адрес и IPv6 (128-битный) адрес.




-------- Транспортный уровень (Transport Layer) --------

Для чего нужен: передавать данные по маршруту, построенному на предыдущем уровне.

Примеры протоколов: TCP, UDP.

Как работает: устанавливает надёжное соединение между устройствами, а затем следит за передачей данных по нему и исправляет ошибки.

Главных протокола здесь два:
-> TCP (Transmission Control Protocol) — гарантирует передачу всех данных без потерь. Полезен при отправке текстовых файлов.
-> UDP (User Datagram Protocol) — не гарантирует передачу данных без потерь, но обеспечивает хорошую скорость. Полезен при просмотре видео или прослушивании музыки в интернете.




-------- Прикладной уровень (Application Layer) --------

Для чего нужен: настраивать связи между приложениями — например, между браузером и серверным софтом.

Примеры протоколов: HTTP, FTP, SMTP.

Как работает: использует различные протоколы и сервисы, которые помогают приложениям обмениваться данными по интернету.

На прикладном уровне хранятся протоколы для всего, что нужно человеку: отправки имейлов, веб-браузинга, передачи файлов и удалённого доступа. Вот некоторые из них:

- HTTP (HyperText Transfer Protocol) — самый популярный протокол для передачи данных по интернету.
- FTP (File Transfer Protocol) — ещё один известный протокол, заточенный под передачу файлов.
- SMTP (Simple Mail Transfer Protocol) — протокол для отправки электронных писем.
- DNS (Domain Name System) - назначение IP-адресам понятных доменных имен.

Этот уровень нужен, чтобы упростить пользователям передачу данных по интернету. Именно с его помощью программисты и обычные пользователи взаимодействуют с моделью TCP/IP.



------------------ МЕТОДЫ ЗАПРОСОВ HTTP -------------------
HTTP – это HyperText Transfer Protocol. Если перевести аббревиатуру с английского языка, то ее значение будет звучать как «протокол передачи гипертекста». Соответствующий компонент представлен протоколом прикладного уровня, который используется для предоставления доступа ко всем ресурсам в пределах Всемирной паутины.

В виде гипертекста понимается текст, который формируется в понятном для пользователя (человека) представлении. Он может включать в себя ссылки на различные дополнительные ресурсы.



--------- Метод GET ---------	
Запрашивает определенный ресурс. Дополнительные сведения могут быть переданы через строку запроса (Query String) в составе URL. Длина запроса ограничена (макс. длина URL - 2048). Запрос доступен для кеширования данных.


--------- Метод POST ---------
Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде. Обычно метод POST используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы. В отличие от метода GET запросы POST не могут быть кешированы.


----- GET для безопасных действий, POST для опасных -----
Говоря совсем просто, GET-запросы лучше не использовать с приватной информацией. Вот почему:

- Они кешируются. Это значит, что логин и пароль, переданные через GET-запрос, могут остаться в интернете навсегда, например, в веб-архиве или кеше Гугла.
- Остаются в истории браузера. Чтобы узнать, какие данные отправлялись, достаточно нажать Ctrl+H.
- Сохраняются в закладках и пересылаются. Можно не обратить внимания и опубликовать в соцсетях или отправить ссылку с приватной информацией в GET-запросе.
- Сохраняются в логах сервера. Например, нельзя отправлять данные банковских карт через GET-запрос, так как это создаёт риски для пользователей.

Таким образом, любые важные данные — логины, пароли, данные карты, персональные данные — лучше передавать с помощью метода POST. Также метод POST поддерживает тип кодирования данных multipart/form-data, что позволяет передавать файлы.


--------- Метод PUT ---------
Метод PUT в HTTP используется, чтобы полностью заменить все текущие данные целевого ресурса (например, файл или запись в базе данных) на те данные, которые были отправлены в запросе. 
Если вы используете метод PUT для какого-либо ресурса, то вы переписываете всю существующую информацию на новую.



--------- Метод PATCH ---------
Позволяет внести частичные изменения в указанный ресурс по указанному расположению.
Метод PATCH в HTTP используется для внесения частичных изменений в ресурс. 
Вместо того чтобы заменять весь ресурс новыми данными, как это делает метод PUT, 
метод PATCH позволяет отправлять только те части ресурса, которые требуют изменения.




--------- Метод DELETE ---------
Позволяет удалить существующие ресурсы на сервере. 
Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (Denial of Service, DoS) из-за удаления критически важных файлов сервера.



--------- Метод HEAD ---------
Обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Метод HEAD при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении GET-запроса к тому же ресурсу. 
Запрос с использованием метода HEAD обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.



--------- Метод OPTIONS ---------
Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.
Когда клиент отправляет запрос методом OPTIONS, сервер отвечает, предоставляя информацию о том, 
какие методы запросов, заголовки и другие параметры могут быть использованы для взаимодействия с этим ресурсом.



--------- Метод TRACE ---------
При отправке запроса методом TRACE сервер принимает этот запрос, а затем возвращает его обратно клиенту в виде ответа. 
Это позволяет клиенту увидеть, через какие промежуточные серверы и прокси-серверы прошел запрос на пути к целевому ресурсу.



--------- Метод CONNECT ---------
Метод CONNECT устанавливает "туннель" между клиентом и сервером. 
Это часто используется для установления защищенных соединений, например, при работе через прокси-сервер.
Такой туннель позволяет клиенту и серверу обмениваться данными в безопасной среде, обеспечивая конфиденциальность и безопасность информации.




------------ HTTP-сообщения: запросы и ответы ------------
Данные между клиентом и сервером в рамках работы протокола передаются с помощью HTTP-сообщений. Они бывают двух видов:

Запросы (HTTP Requests) — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок.
Ответы (HTTP Responses) — сообщения, которые сервер отправляет в ответ на клиентский запрос.
Само по себе сообщение представляет собой информацию в текстовом виде, записанную в несколько строчек.


В целом, как запросы HTTP, так и ответы имеют следующую структуру:

1) Стартовая строка (start line / request line) — используется для описания версии используемого протокола и другой информации — вроде запрашиваемого ресурса или кода ответа. Как можно понять из названия, ее содержимое занимает ровно одну строчку.
2) HTTP-заголовки (HTTP Headers) — несколько строчек текста в определенном формате, которые либо уточняют запрос, либо описывают содержимое тела сообщения.
3) Пустая строка (разделитель), которая сообщает, что все метаданные для конкретного запроса или ответа были отправлены.
Опциональное тело сообщения, которое содержит данные, связанные с запросом, либо документ (например HTML-страницу), передаваемый в  ответе.
Рассмотрим атрибуты HTTP-запроса подробнее.


------ Стартовая строка -------
Стартовая строка HTTP-запроса состоит из трех элементов:

1) Метод HTTP-запроса (method, реже используется термин verb). Обычно это короткое слово на английском, которое указывает, что конкретно нужно сделать с запрашиваемым ресурсом. Например, метод GET сообщает серверу, что пользователь хочет получить некоторые данные, а POST — что некоторые данные должны быть помещены на сервер.
2) Цель запроса. Представлена указателем ресурса URL, который состоит из протокола, доменного имени (или IP-адреса), пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров HTTP-запроса и еще ряд опциональных элементов.
3) Версия используемого протокола (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой строкой данных.

Давайте напишем пример стартовой строки HTTP запроса для получения страницы:

GET /page/test HTTP/1.1

А теперь пример запроса для отправки данных:

POST /page/test HTTP/1.1


------ Заголовки ------
HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. 
Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. 
Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного заголовка. 
Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.

Давайте, для примера, рассмотрим один реальный запрос к серверу.

Запрос от браузера (в данном примере тело запроса отсутствует):

GET / HTTP/1.1
Host: webkyrs.info
User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:18.0) Gecko/20100101 Firefox/18.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Cookie: wp-settings
Connection: keep-alive


------- Самые частые заголовки запроса -------
--> Host
Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.

--> User-Agent
Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.

--> Accept
Заголовок Accept предназначен для информирования сервера о типах данных, которые поддерживаются клиентом (браузером). В этом заголовке браузер перечисляет, какие типы документов он "понимает". Пере-
числение идет через запятую.
Пример использования:
Accept: text/html, text/plain, image/jpeg


--> Cookie
Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (‘ ; ‘), который  используется как разделитель.

--> Authorization
Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.

--> Referer
Это поле позволяет клиенту указать URL ресурса, с которого был запрошен URL. Синтаксис следующий:
Referer: URL
Как следует из названия (Referer), этот HTTP header содержит ссылочный url.
Например, если я зашел на домашнюю страницу Nettuts + и нажал ссылку на статью, этот header будет отправлен в мой браузер:
Referer: https://net.tutsplus.com/




------- Тело запроса (request body) -------
Завершающая часть HTTP-запроса — это его тело. Не у каждого HTTP-метода предполагается наличие тела. 
Так, например, методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. 
Некоторые виды запросов  могут отправлять данные на сервер в теле запроса: самый распространенный из таких методов — POST.



---------------- Ответы HTTP ----------------

HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос. 
Его структура похожа на структуру HTTP-запроса: стартовая строка, заголовки и тело.

----- Строка статуса (Status line) -----
Стартовая строка HTTP-ответа называется строкой статуса (status line). На ней располагаются следующие элементы:

- Версия протокола (HTTP/2 или HTTP/1.1).
- Код состояния, который указывает, насколько успешно завершилась обработка запроса.
- Пояснение — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.

Пример: HTTP/1.1 200 OK


----- Заголовки ответа ----- 
Response Headers, или заголовки ответа, используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела. Они существуют в том же формате, что и остальные заголовки, а именно  «Имя-Значение» с двоеточием (:) в качестве разделителя.

Ниже приведены наиболее часто встречаемые в ответах заголовки:

--> Cache-Control
Определение из w3.org: «Поле заголовка Cache-Control используется для указания директив, которые ДОЛЖНЫ выполняться всеми механизмами кэширования по цепочке запросов/ответов». 
Эти «механизмы кэширования» включают шлюзы и прокси, которые может использовать ваш интернет-провайдер.
Пример:
Cache-Control: max-age=3600, public

"public" означает, что ответ может быть кэширован кем угодно. "max-age" указывает, сколько секунд действителен кеш. Разрешение кэширования вашего сайта может снизить нагрузку на сервер и пропускную способность, а также увеличить время загрузки в браузере.


--> Content-Type
Заголовок-сущность Content-Type используется для того, чтобы определить MIME тип ресурса.
В ответах сервера заголовок Content-Type сообщает клиенту, какой будет тип передаваемого контента. 
В некоторых случаях браузеры пытаются сами определить MIME тип передаваемого контента, но их реакция может быть неадекватной.

Синтаксис:
Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data; boundary=something


--> Заголовок Content-length
Этот заголовок содержит строку, в которой записана длина передаваемых данных в байтах при использовании метода передачи POST.
Если задействуется метод GET, то этот заголовок отсутствует.




При отправке формы мы отправляем какие-то данные. Так как в HTTP не предусмотрены специальные места для отправки данных из форм, они отправляются в теле запроса. При этом в зависимости от того, какой заголовок Content-Type установлен, интерпретируется то, как будут закодированы данные при отправке. Обычно используется следующий формат Content-Type: application/x-www-form-urlencoded. Это простой формат — ключ равно значение и амперсанд между ними.

login=smith&password=12345678
Таким нехитрым способом мы можем продолжать строку, передавая столько данных, сколько захотим. Теперь попробуем сделать запрос к нашему локальному серверу.

telnet localhost 8080

POST /login HTTP/1.1
Host: hexlettesthost.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

login=smith&password=12345678 # отправляем данные
HTTP/1.1 200 OK
X-Powered-By: Express
Connection: close
Content-Type: text/html; charset=utf-8
Content-Length: 7
ETag: W/"c-r0WEeVxJ7IpMIG20rN7HX9ndB4c"
Date: Thu, 09 Jul 2020 03:32:54 GMT

Done!
Connection closed by foreign host.




------------- Существует несколько способов работы API, например:

- SOAP API
- REST API
- Websocket API
- RPC API


1) REST - это архитектурный стиль взаимодействия компонентов приложения в сети, также это особый тип Web API. 
Архитектурный стиль - это набор ограничений и принципов проектирования свойств системы, которые необходимы для лучшего масштабирования и интеграции с другими сервисами.

2) SOAP - это протокол, по которому взаимодействуют веб-сервисы между друг другом или с клиентом.

3) Websocket API - это одна из разработок web API, которая позволяет открыть постоянное двунаправленное сетевое соединение между клиентом и сервером. Использует JSON для передачи данных.

Пример типов сообщений:

Subscribe (подписка на топик)
Unsubscribe (отписка на топик)
Message (получение сообщений)
Oauth.logheartbit (контроль статуса соединения)

4) RPC API - система удаленного вызова процедур. Клиент совершает функцию на сервере, и сервер отправляет обратно результат.

