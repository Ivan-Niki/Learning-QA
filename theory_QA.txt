
==================== ЧТО ТАКОЕ ТЕСТИРОВАНИЕ ====================

Тестирование программного обеспечения (Software Testing) - проверка соответствия между реальным и ожидаемым поведением программы, 
осуществляемая на конечном наборе тестов, выбранном определенным образом.
В более широком смысле, тестирование - это одна из техник контроля качества, включающая в себя активности по 
планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).




==================== ЧТО ТАКОЕ КАЧЕСТВО ПО ===================

Качество ПО — это совокупность свойств и характеристик программного обеспечения, которые определяют его способность удовлетворять требованиям и ожиданиям пользователя.
Оно может быть измерено на основе различных критериев, таких как функциональность, надежность, производительность, удобство использования, безопасность и т.д.
Качество ПО может быть улучшено с помощью процессов тестирования, анализа, управления изменениями, управления рисками и других методов.




==================== ЦЕЛИ ТЕСТИРОВАНИЯ ====================

Три ключевые цели тестирования:
1. Повысить вероятность того, что разрабатываемое приложение будет работать правильно при любых обстоятельствах.
2. Повысить вероятность того, что разрабатываемое приложение будет соответствовать всем описанным требованиям.
3. Предоставление актуальной информации о состоянии продукта на момент тестирования (предоставление информации 
о статусе готовности заявленной функциональности системы или приложения).

Также можно определить дополнительные цели тестирования:
--> Оценка рисков. Тестирование помогает оценить риски, связанные с продуктом и его функциональностью. 
Это может помочь в принятии решений о дальнейшей разработке и релизе ПО.
--> Улучшение процесса разработки. Тестирование может помочь улучшить процесс разработки ПО. Результаты тестирования могут помочь выявить слабые места в процессе, которые можно улучшить для повышения эффективности и качества разработки.

Результатом тестирования непосредственно для компании разработчика продукта служит сокращение потенциальных дополнительных трат на исправление ошибок в релизной версии и снижение репутационных рисков, ведь любой обнаруженный дефект негативно влияет на доверие пользователей к продукту.



================= Почему важно тестировать программы =================

Тестирование программ является важной практикой по нескольким причинам:
--> Выявление ошибок. Позволяет обнаружить ошибки и недочеты в программном обеспечении. 
Раннее обнаружение и исправление ошибок способствует улучшению качества программы и уменьшению возможных проблем и рисков в дальнейшем.
--> Гарантия качества. Помогает проверить, насколько программа соответствует своим требованиям и спецификациям. 
Это позволяет удостовериться, что программа работает правильно, выполняет задачи и доставляет ожидаемые результаты.
--> Улучшение надежности. Способствует повышению надежности программного обеспечения. 
Через тестирование можно выявить уязвимости, ошибки в обработке данных и другие проблемы, которые могут привести к сбоям или неправильной работе программы.
--> Оптимизация производительности. Позволяет оценить производительность программы, выявить узкие места и бутылочные горлышки, которые могут замедлять работу программы.
--> Повышение удовлетворенности пользователей. Позволяет выявить и исправить проблемы, которые могут негативно влиять на пользовательский опыт. 
Корректная и надежная работа программы улучшает удовлетворенность пользователей и способствует их лояльности.
--> Уменьшение рисков и затрат. Помогает снизить риски, связанные с неправильной работой программы. 
Обнаружение и устранение ошибок на ранних стадиях разработки экономит время, усилия и ресурсы, которые могут быть затрачены на исправление проблем в более поздних этапах.

В целом, тестирование программ позволяет обеспечить высокое качество программного обеспечения, минимизировать риски и повысить доверие пользователей.





================= ЖИЗНЕННЫЙ ЦИКЛ БАГА ================

Жизненный цикл бага (bug life cycle) - это этапы, которые проходит баг от создания до закрытия.
Каждый этап работы с багом обозначается в баг-трекинговой системе как "Status". Статус показывает, какая работа ведётся над багом в данный момент.
Жизненный цикл бага может содержать следующие стадии:

--> Открыт/Новый (Opened/New) — тестировщик выявил баг и добавил в репорт. Этот статус присваивается автоматически.
--> В работе (In Progress) — о баге сообщили исполнителю (чаще всего разработчику), и он занимается исправлением.
--> Исправлен (Fixed/Resolved) - когда разработчик внесет необходимые правки в код и проверит изменения, он может поменять статус бага на “Исправлен”.
--> Готов к повторной проверке/тестированию (Ready for check/test) — как только дефект исправлен, разработчик передает код на повторное тестирование. Поскольку на этом этапе тестировщик еще не завершил тестирование, присваивается статус “Ожидает повторного тестирования”.
--> Повторное тестирование (Retest) - тестировщик проводит повторное тестирование кода, чтобы проверить, исправлен ли дефект разработчиком, и меняет статус на “Повторное тестирование”. После стадии Retest может быть
два варианта:

1) Закрыт (Closed) — если бага больше не существует, тестировщик присваивает ему статус “Закрыт” (баг устранен и больше не воспроизводится).
2) Повторное открыт (ReOpened) - если после внесенных разработчиком исправлений баг НЕ исчез, тестировщик меняет его статус на “Повторно открыт”. После этого баг снова проходит через весь жизненный цикл.

Кроме основных есть еще несколько статусов:
-> Отклонен (Rejected) — исправлению бага помешала ошибка в репорте, например неверный алгоритм в пункте «Шаги к воспроизведению».
-> Отсрочен (Deferred) — баг признан неприоритетным и исправление переносится.
-> Дубликат (Duplicate) - если дефект повторяется дважды или соответствует концепции другого бага, ему присваивается статус “Дубликат”.
-> Не баг (Not a Bug) - если баг не влияет на функциональность приложения, то ему присваивается статус “Не баг”.



===================== VERIFICATION and VALIDATION ========================

Verification (Верификация) - это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, требованиям, сформированным в начале этого этапа.
Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определённые в начале текущей фазы.
Верификация - это проверки, выполняемые в процессе разработки ПО для ответа на вопрос: "правильно ли мы разрабатываем продукт?". Это в т.ч. включает проверку документации: requirements specification, design documents, database table design, ER diagrams, test cases, traceability matrix и т.д. Верификация гарантирует, что ПО разрабатывается в соответствии со стандартами и процессами организации, полагаясь на reviews и статические методы тестирования (т.е. без запуска ПО, но, например, с unit/integration tests).
Верификация является превентивным подходом (Preventative approach).
Верификация - это подтверждение путем представления объективных доказательств выполнения данным рабочим элементом установленных требований. (ГОСТ 56920)


Validation (Валидация) - это определение соответствия разрабатываемого ПО ожиданиям и потребностям заказчика (пользователя), его требованиям к системе.
Валидация - это процесс оценки конечного продукта, чтобы проверить, соответствует ли он потребностям бизнеса и ожиданиям клиентов, т.е. отвечает на вопрос: "правильный ли мы разработали продукт?". 
Валидация является динамическим тестированием, т.е. происходит с помощью выполнения кода и прогона тестов на нём (UAT/CAT, usability, всё что угодно). 
Валидация является реактивным подходом (Reactive approach).
Валидация демонстрирует, что рабочий элемент может использоваться пользователями для решения определенных ими задач. (ГОСТ 56920)


Если попробовать привести очень упрощенный пример, представим блюдо в ресторане. 
Верификация будет включать проверку технологической карты, оценку процесса приготовления (температуры, времени и т.п.). 
На протяжении этого процесса можно будет примерно быть уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его приготовим. 
Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.



---------- Идентификация, аутентификация и авторизация ----------

Идентификация, аутентификация и авторизация – три процесса защищающие Ваши данные или денежные средства от доступа посторонних лиц.

1) Идентификация (Identification) — процесс распознавания пользователя по его идентификатору.
2) Аутентификация (Authentication) — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает.
3) Авторизация (Authorisation) — предоставление определённых прав.


Рассмотрим на примере с доступом в онлайн-банкинг. Каждое действие пользователя и системы рассмотрим подробно.

--------- Идентификация ---------
Находясь на сайте банка, пользователь решает зайти в личный кабинет, чтобы сделать денежный перевод. На странице личного кабинета система вначале просит ввести идентификатор. Это может быть логин, имя и фамилия, адрес электронной почты или номер мобильного телефона.
Какой конкретно вид данных необходимо ввести – зависит от ресурса. Данные, которые указывались при регистрации, необходимо ввести для получения доступа. Если при регистрации указывалось несколько типов данных – и логин, и адрес электронной почты, и номер мобильного, то система сама подскажет что ей конкретно нужно.
Ввод этих данных необходим для идентификации человека за монитором как пользователя конкретно этого банка.
Если пользователь в качестве идентификатора ввел «Александр Петров», и система нашла в своей базе запись о пользователе с таким именем, то идентификация завершилась.

--------- Аутентификация ---------
После идентификации следует процесс аутентификации, в котором пользователю нужно доказать, что он является человеком, который регистрировался под именем Александр Петров.
Для доказательства необходимо наличие одного из типов аутентификационных данных:
-> Нечто, присущее только пользователю. Биометрические данные: сканеры лица, отпечатки пальцев или сетчатки глаза.
-> Нечто, известное только пользователю. Сюда относятся pin-коды, пароли, графические ключи, секретные слова.
-> Нечто, имеющееся у пользователя. В данном качестве может выступать токен, то есть компактное устройство, предназначенное для обеспечения информационной безопасности пользователя, также используется для идентификации владельца. Самые простые токены не требуют физического подключения к компьютеру – у них имеется дисплей, где отображается число, которое пользователь вводит в систему для осуществления входа; более сложные подключаются к компьютерам посредством USB и Bluetooth-интерфейсов.
Самый распространенный тип аутентификационных данных – это пароль. Именно поэтому так важно создавать и правильно хранить свои пароли.
После ввода пользователем пароля система проверяет: соответствует ли условный пароль «Q45fp02@13» пользователю с именем Александр Петров. Таким образом происходит аутентификация.

Аутентификация бывает одно-, двух- и трёхфакторной.
- Однофакторная аутентификация требует подтверждения только одним способом — например, с помощью пароля. Она встречается чаще всего.
- Двухфакторная аутентификация используется в системах, которые хранят важные или личные данные. Например, в банковских приложениях или в социальных сетях. При входе в соцсеть у пользователя могут попросить не только пароль, но и другую информацию — код из СМС или биометрические данные.
- Трёхфакторная аутентификация - встречается в системах с повышенными требованиями к безопасности — например, в банковской сфере. Третьим фактором, позволяющим подтвердить личность, могут быть электронные ключи доступа. Электронный ключ хранится на специальном USB-накопителе и подключается в момент подтверждения доступа.

--------- Авторизация ---------
Если все верно, и пара логин-пароль верны, то система предоставит пользователю доступ к его ресурсам и совершение банковских операций, то есть произойдет авторизация. Авторизация определяет набор привилегий и прав, доступных конкретному пользователю. Например, открывает доступ к просмотру баланса иили совершению денежных переводов.

Описанные процессы всегда происходят только в таком порядке: идентификация, аутентификация, авторизация. Вся цепочка потеряет смысл, если, например, сайт сначала предоставит доступ к денежным средствам пользователя, а потом будет уточнять, он ли это на самом деле.
Процессы идентификации, аутентификации и авторизации характерны не только для онлайн-банкинга, но и для электронной почты, социальных сетей и других ресурсов.




------------- QA, QC, Testing – в чем разница -------------

TESTING (тестирование) – представляет собой проверку создаваемого программного продукта на соответствие требованиям к этому продукту. Основная задача тестирования – это выявить и зафиксировать дефекты. Т.е. это проверка какого-то функционала и поиск в нём багов (по уже составленным чек-листам и тест-кейсам).
-> Суть: Detection (англ.) – обнаружение, выявление, диагностика.
-> Фокус направлен на исходный код и дизайн программного обеспечения.
-> Проводится на стадии тестирования и в процессе разработки ПО.

QUALITY CONTROL (контроль качества) – более обширное понятие, сюда входит не только поиск багов, но и анализ этих багов, анализ результатов тестирования. Предоставление отчетности, готовность к релизу, апдейт чек-листов, составление отчета о качестве продукта перед релизом, что нет критических багов. Соответствует ли это ПО требованиям заказчика, спецификациям, ТЗ и т.д. Можно ли выкатывать продукт в продакшен. Работает с двумя понятиями – верификацией и валидацией, т.е. отвечает на вопросы: 
1) правильно ли мы делаем наше программное обеспечение (verification);
2) правильное ли программное обеспечение мы делаем (validation).
-> Суть: Verification/Validation (англ.) - проверка/подтверждение.
-> Фокус направлен на продукт.
-> Проводится перед выпуском продукта.


QUALITY ASSURANCE (гарантия качества, обеспечение качества, убеждённость в качестве) – поиск решений для того, чтобы баги не появлялись. 
Главная задача QA – это не поиск багов в готовом ПО, а bugs-prevention (профилактика). Т.е. основная задача QA-отдела – это уменьшить количество багов, предотвратить их появление в принципе. 
В QA-отдел могут входить не только тестировщики и QA-инженеры, но также BA, PM.
QA-отдел начинает свою работу ещё тогда, когда нет ПО; его главная задача – определиться, как построить работу для того, чтобы багов было меньше.
QA-инженер составляет тест план, методологии, выбирает техники тест-дизайна, составляется документация, осуществляет помощь в составлении требований и чекинг требований.
-> Prevention (англ.) – профилактика, предупреждение, предотвращение, недопущение.
-> Фокус направлен на процессы.
-> Проводится на всех этапах жизненного цикла разработки ПО.



----------- ЖИЗНЕННЫЙ ЦИКЛ РАЗРАБОТКИ ПО (SDLC) -------------

SDLC (software development life cycle) начинается в момент принятия решения о том, что нам нужно какое-то ПО и заканчивается в момент вывода этого ПО из эксплуатации.
--> 0. Idea;
--> I. Сбор и анализ требований (какие проблемы требуют решений? Что хочет от нас заказчик?) Работают SA (system analyst), BA, PM, PO (product owner);
--> II. Архитектура и дизайн (Каким образом мы это сделаем?).
--> III. Разработка (Регулирует процесс создания продукта). *требования могут меняться на этапе разработки, если что-то не учли на этапе проектирования и дизайна.
--> IV. Тестирование (тестировщики используют продукт, сделанный на этапе разработки и пытаются сопоставить его с теми требованиями, которые были собраны на первом этапе). 
--> V. Релиз (Продукт доступен всем конечным пользователям) *они могут зайти на сайт или скачать приложение или оплатить что-то и т.д.
--> VI. Поддержка (Maintenance, Support) (чинятся баги, дописываются новые фичи, изменяются существующие функциональности, осуществляется поддержка пользователей).
Поддержку можно представить как повторяющуюся цепочку шагов:
«Определение новых требований» --> «Разработка» --> «Тестирование» --> «Развертывание».

--> Вывод из эксплуатации (смерть проекта). 
Закрытие – последний этап жизни ПО. На нем происходит вывод продукта из эксплуатации, его замена на современные аналоги, либо новые версии.
Как пример, можно вспомнить браузер Internet Explorer (был замен на Edge).


----------- ЖИЗНЕННЫЙ ЦИКЛ ТЕСТИРОВАНИЯ ПО (STLC) -------------

STLC (Software Testing Lifecycle) - это процесс тестирования, который включает в себя определенную последовательность шагов, чтобы гарантировать достижение целей в области качества. В процессе STLC каждое действие выполняется планомерно и систематически. Каждый этап имеет разные цели и результаты. У разных организаций разные этапы STLC, однако основа остается прежней.
STLC имеет несколько взаимосвязанных фаз и в целом очень похож на SDLC. Эти фазы являются последовательными и называются:

1) Анализ требований (Requirement Analysis): один из важнейших этапов, потому что именно на нем можно почти бесплатно исправить недостатки проекта. Этап анализа требований также определяет потенциальную потребность в автоматизированном тестировании и позволяет производить экономические расчеты затрат на рабочую силу на основе оценки проекта. На этом же этапе обсуждаются и документируются критерии начала и окончания тестирования.

2) Планирование тестирования (Test Planning): на этом этапе формируется план тестирования, т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования (участники и их роли, инструменты, окружение). 
Во время планирования мы также пытаемся определить метрики, метод сбора и отслеживания этих метрик. 
План составляют исходя из требований, тестовой стратегии и анализа рисков.

3) Разработка тест-кейсов (Test Case Development): на этом этапе команда создает тест-кейсы, которые описывают шаги, необходимые для тестирования программного обеспечения. Тесты должны покрывать все возможные сценарии, чтобы найти как можно больше проблем и ошибок в программе. Качество и эффективность тест-кейсов, разработанных на этом этапе, играют жизненно важную роль для успешного тестирования.

На этапе разработки тест-кейсов выполняются следующие действия:
-> Определение тест-кейсов для разработки.
-> Создание простых и понятных тест-кейсов.
-> Определение ожидаемых результатов для каждого тест-кейса.
-> Проверка и валидация тест-кейсов.

По завершении этого этапа команда тестирования должна иметь набор тест-кейсов, которые помогают проверить все функциональности и возможности программного обеспечения. Это гарантирует, что все проблемы будут обнаружены и исправлены до релиза ПО.


4) Настройка тестовой среды (Test Environment Setup).
Для выполнения разработанных тестовых сценариев необходимо создать условия подходящего тестового окружения, такие как серверы, платформы, аппаратное и программное обеспечение. Важно, чтобы тестовая среда охватывала все среды, в которых будет работать пользователь.
На этом этапе STLC настраиваются операционные системы и виртуальные машины, развертываются инструменты тестирования, такие как Selenium, Katalon Studio, а также тестовая среда и базы данных проекта. Мы также обращаемся с запросами к DevOps и администраторам, если требуется поддержка.

Например, некоторые функции, работающие в Google Chrome, не работают в Microsoft Edge. Функция может без проблем запускаться с 16 ГБ ОЗУ, но может создавать проблемы с 4 ГБ ОЗУ. Основным результатом этого этапа является готовая стратегия управления тестовыми средами.

На этом этапе:
--> определяется программное и аппаратное обеспечение, необходимое для разных уровней производительности;
--> расставляются приоритеты тестовых сред;
--> проводится настройка тестовых сред;


5) Выполнение тестов (Test Execution): тесты выполняются на основе готовой тестовой документации и правильно настроенной тестовой среды. Все результаты тестирования регистрируются в Системе управления тестированием (TMS). Отрицательно пройденные тесты, в которых фактический результат отличается от ожидаемого, регистрируются как ошибки и передаются команде разработчиков на доработку с последующей перепроверкой после исправления.
Как только команда разработчиков устраняет ошибку, начинается повторное (регрессионное) тестирование ПО. Все функции важно снова проверить, потому что исправление ошибки может привести к возникновению новых проблем в другом модуле решения. Какие конкретно существуют этапы тестирования — зависит от специфики проекта и проводимых видов тестов.

Результатом данного этапа считается отчёт по качеству с результатами тестирования. Он составляется командой тестирования и отправляется заказчику с оговоренной периодичностью.

6) Завершение цикла испытаний (Test Cycle Closure): 
Окончание тестирования и выпуск конечного продукта (выход в релиз) знаменуют начало фазы завершения тестирования. На этом этапе выполняется окончательная генерация отчетов о тестировании для клиента. 
Они должны включать затраченное время, процент обнаруженных ошибок и положительных результатов тестирования, общее количество обнаруженных и исправленных ошибок. 
Что касается отдела тестирования, то это момент для анализа его работы, подведения итогов, анализа его продуктивности и возможности внести предложения по улучшению качества тестирования.




-------------- Матрица трассировки -------------

Матрица трассируемости (RTM - Requirement Traceability Matrix) - двумерная таблица, описывающая связь двух сущностей (например, требований и тестовых сценариев). 
Таблица позволяет производить прямую и обратную трассировку от одной сущности к другой, обеспечивая таким образом возможность определения покрытия и оценки влияния предполагаемых изменений. (ISTQB)

Матрица трассируемости (Requirement Traceability Matrix AKA Traceability Matrix or Cross Reference Matrix) используется для документирования связей между требованиями и тест-кейсами по этим требованиям и наглядного отображения трассируемости в виде простой таблицы.
Матрица трассируемости может служить одновременно в качестве матрицы покрытия. 
Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет.



-------------- Что такое плавающий баг? -------------

Нежелательное поведение программы, которое возникает спонтанно и непредсказуемо, называют плавающим багом, или гейзенбагом (с отсылкой к немецкому физику Вернеру Карлу Гейзенбергу – автору принципа неопределенности из квантовой физики). 
Загадочное поведение программы, которое невозможно воспроизвести или зафиксировать – одно из самых сложных явлений в работе инженеров по QA. 
Обнаружить, поймать и превратить в обычный – схема охоты на плавающий баг. 
Говорят, будто плавающие баги есть в любой программе, просто некоторые из них еще ни разу не проявились.





--------------- УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels) в Тестировании ПО ---------------

Acceptance Testing
      ↑
System Testing
      ↑
Integration Testing
      ↑
Module/Unit/Component testing


---------- Модульное/юнит/компонентное тестирование -----------

Компонент (component) - наименьший элемент программного обеспечения, который может быть протестирован отдельно.
Компонентное тестирование (component testing) - тестирование отдельных компонентов программного обеспечения.

Модульное тестирование (оно же юнит-тестирование) используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. 
Очевидно, что это тестирование методом БЕЛОГО ящика и чаще всего оно проводится самими разработчиками.
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов.

Компонентное тестирование - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который проводится командой QA.


---------- Интеграционное тестирование (Integration testing) -----------

Интеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами).
Смысл интеграционного тестирования заключается в процессе тестирования интерфейсов между двумя компонентами или программными модулями для оценки того, как данные передаются между ними.
Интеграционное тестирование обычно проводится после модульного тестирования, которое включает в себя тестирование отдельных модулей и блоков. 
После того, как установлено, что каждый блок работает изолированно, интеграционное тестирование оценивает, как эти блоки работают при объединении.

Зачем нужно интеграционное тестирование:
— Разные разработчики используют разную логику при разработке модулей даже для одного и того же программного приложения. Интеграционное тестирование — это единственный способ убедиться, что отдельные модули работают вместе так, как должны.
— Когда данные переходят от одного модуля к другому, структура этих данных может измениться, а некоторые значения могут быть удалены. Это может вызвать значительные проблемы в работе модулей.
— Модули взаимодействуют со сторонними инструментами и API. Важно протестировать интеграцию, чтобы убедиться, что данные, принимаемые API или сторонним инструментом, корректны, а генерируемые ответы также соответствуют ожиданиям.
— Если разработчик внедряет изменения без модульного тестирования, интеграционное тестирование необходимо для оценки эффективности изменений.

Уровни интеграционного тестирования:
- Компонентный интеграционный уровень (Component Integration testing)
Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
- Системный интеграционный уровень (System Integration Testing)
Проверяется взаимодействие между разными системами после проведения системного тестирования.

Подходы к интеграционному тестированию:
1) Подход большой взрыв ("Big Bang" Integration).
Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.

2) Инкрементальный подход (Incremental Approach).
При таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. Осуществляется разными методами:

- Сверху вниз (нисходящий подход) (Top-Down Integration)
Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.

- Снизу вверх (восходящий подход) (Bottom-Up Integration)
Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. 
Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения.

- Гибридный/сэндвич-подход (Sandwich/Hybrid Approach)
Представляет собой комбинацию восходящего и нисходящего подходов. Здесь целью является средний слой, в то время как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны.



---------- Системное тестирование (System Testing) -----------

Системное тестирование означает тестирование всей системы в целом, оно выполняется после интеграционного тестирования, чтобы проверить, работает ли вся система целиком должным образом. 
В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.
Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом.
Для минимизации рисков, связанных с особенностями поведения системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.


Можно выделить два подхода к системному тестированию:
--> на базе требований (requirements based)
Для каждого требования пишутся тестовые случаи (test cases), проверяющие выполнение данного требования.
--> на базе случаев использования (use case based)
На основе представления о способах использования продукта создаются случаи использования системы (Use Cases). 
По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария пишутся тест кейсы (test cases), которые должны быть протестированы.



---------- Приемочное тестирование (Acceptance testing - AT) -----------

Приемочное тестирование – это комплексное тестирование, необходимое для определения уровня готовности системы к последующей эксплуатации. Тестирование проводится на основании набора тестовых сценариев, покрывающих основные бизнес-операции системы.

Приемочное тестирование (Acceptance Testing) - формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:
- определения удовлетворяет ли система приемочным критериям;
- вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.

Приемочное тестирование выполняется на основании набора типичных тестовых случаев и сценариев, разработанных на основании требований к данному приложению.

Решение о проведении приемочного тестирования принимается, когда:
- продукт достиг необходимого уровня качества;
- заказчик ознакомлен с Планом Приемочных Работ (Product Acceptance Plan) или иным документом, где описан набор действий, связанных с проведением приемочного тестирования, дата проведения, ответственные и т.д.

Виды приемочного тестирования:
1) Пользовательское приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям.
2) Бизнес - приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам.
3) Правовое приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается.
4) Операционное тестирование (OAT - Operational Acceptance testing) проводится с целью убедиться, что система выполняет свою роль в среде эксплуатации согласно бизнес-модели. Данный вид тестирования проводится до пользовательского приемочного тестирования.
Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment).
5) Альфа-тестирование (Alpha Testing) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. Альфа-тестирование часто используется как форма внутреннего приемочного тестирования перед проведением бета-тестирования.
6) Бета-тестирование, полевые испытания (Beta Testing, Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде.
Бета-тестирование проводится после альфа-тестирования и может использоваться как приемочное тестирование внешними пользователями. Бета-версия системы передается группе пользователей вне команды разработки, чтобы снизить количество дефектов. Иногда версия передается нескольким командам, чтобы получить обратную связь от как можно большего количества будущих пользователей.



------------- Критерии начала и окончания тестирования (protesting) -------------

Критерии начала тестирования:
- готовность тестовой платформы (тестового стенда)
- законченность разработки требуемого функционала
- наличие всей необходимой документации

Критерии окончания тестирования:
- результаты тестирования удовлетворяют критериям качества продукта:
  1. требования к количеству открытых багов выполнены
  2. выдержка определенного периода без изменения исходного кода приложения Code Freeze (CF)
  3. выдержка определенного периода без открытия новых багов Zero Bug Bounce (ZBB)
  


------------ Пирамида тестирования ------------

Пирамида тестирования — это концептуальная модель, которая помогает организовать различные виды тестов в процессе разработки программного обеспечения. Она представляет собой пирамиду, разделенную на уровни, каждый из которых соответствует определенному типу тестирования: от юнит-тестов на нижнем уровне до интеграционных и системных тестов на верхних уровнях. Эта модель помогает разработчикам и тестировщикам понять, какие тесты нужно проводить в большем объеме и на каких этапах разработки.
Пирамида тестирования — это абстракция, которая показывает соотношение видов тестов приложения. 
Основная цель пирамиды — помочь обнаруживать баги на ранних стадиях, когда их исправление значительно дешевле, чем на поздних.
Пирамида тестов — это абстракция, которая отражает группировку тестов программного обеспечения по разным уровням детализации. Также она характеризует относительное количество тестов в каждой группе.
Пирамида тестирования показывает, как выстраивать тесты на проекте. В большинстве случаев должно быть много юнит-тестов, меньше интеграционных тестов и еще меньше системных тестов.

Ключевые утверждения, которые справедливы для пирамиды:
- Наибольший объем тестов должен быть сконцентрирован на нижних уровнях.
- Чем выше поднимаемся по пирамиде, тем дороже и медленнее будут тесты.
- Тяжелых Е2Е-тестов должно быть минимальное количество.
- В построении пирамиды должны участвовать и разработчики, и тестировщики.

Пирамида тестирования в классическом варианте выглядит следующим образом:

    E2E/UI
      ↑
  Integration 
      ↑
     Unit 

 
Можно сказать, что разработка ПО - это движение по пирамиде снизу вверх. Важно отметить:

1) Тест (ручной, на высоких уровнях, или автотест, на низких уровнях), должен быть на том же уровне, что и тестируемый объект. Например, модульный тест (проверяющий функции, классы, объекты и т.п.) должен быть на компонентном уровне. Это неправильно, если на приемочном уровне запускается тест, который проверят минимальную единицу кода.
2)Тесты уровнем выше не проверяют логику тестов уровнем/уровнями ниже.
3)Чем выше тесты уровнем, тем они:
	- сложней в реализации, и соответственно, дороже в реализации;
	- важнее для бизнеса и критичней для пользователей;
	- замедляют скорость прохождения тестовых наборов, например, регресса.




----- Детали пирамиды тестирования -----

- Юнит-тесты (Unit Tests): Находятся на самом нижнем уровне пирамиды. Эти тесты фокусируются на проверке отдельных модулей или компонентов программы. 
Юнит-тесты обычно быстрые и их легко автоматизировать. Их должно быть больше всего в проекте.
В основе пирамиды лежат маленькие, дешевые и быстрые unit-тесты. За их написание и поддержку отвечает команда разработчиков. Весь старый и новый функционал должен быть подкреплен unit-тестами. Именно с их помощью можно быстро и комплексно проверить стабильность приложения.

- Интеграционные тесты (Integration Tests): Расположены на среднем уровне пирамиды. Они проверяют взаимодействие между различными модулями или компонентами. Интеграционные тесты могут быть медленнее и сложнее в поддержке, чем юнит-тесты.
Суть этого процесса в объединении программных модулей в группы и их последующее тестирование. Проще говоря, это проверка бизнес-логики без использования UI. На проекте интеграционные тесты пишут разработчики и они же их и поддерживают. Однако можно встретить команды, где этот уровень закрывает QA.

- Тесты пользовательского функционала / E2E тесты (End-to-End Tests): Находятся на вершине пирамиды. Эти тесты проверяют работу всей системы в условиях, максимально приближенных к реальным. Они часто включают в себя тестирование пользовательского интерфейса и могут быть довольно медленными и затратными. 
Здесь количество тестов должно быть наименьшим. Воссоздавая пользовательские сценарии, мы проверяем приложения на стабильность и работоспособность. На этом уровне тесты самые хрупкие.

В зависимости от проекта, команда может адаптировать стандартную пирамиду тестирования, чтобы лучше соответствовать его специфике и требованиям.
Пирамида тестирования на проекте в более подробном варианте может выглядеть, напрмер, вот так:

E2E tests            ---> QA
    ↑  
UI tests             ---> QA     
    ↑
API tests            ---> QA
    ↑
Integration tests    ---> QA, Dev
    ↑
Unit tests           ---> Dev





-------------- Альтернативные модели пирамиды тестирования -----------------

1) "Мороженое" или "Анти-пирамида".
В этой модели большой акцент делается на E2E тесты, а юнит-тесты почти отсутствуют. Это может привести к высоким затратам на поддержку и медленному процессу разработки.
По мере роста проекта форма пирамиды меняется, становясь больше похожей на мороженое (первёрнутая пирамида).
Такое случается при недостатке низкоуровневых тестов (модульных, интеграционных и компонентных), при избытке тестов, запускаемых через UI, и при ещё большем количестве сквозных (E2E) тестов.
Классическая "мороженка" тестирования, когда основной объем тестов сконцентрирован на поздних стадиях, преимущественно в виде ручного тестирования.
Чаще всего это происходит, когда над проектом работают несколько разных команд, возможно, изолированных друг от друга, и они добавляют тесты на разные уровни пирамиды. Например, разработчики пишут модульные и интеграционные тесты независимо от QA-инженеров, которые пишут сквозные тесты. Это приводит не только к неправильному распределению тестов по уровням пирамиды (потому что некоторые сценарии автоматизируются на нескольких разных уровнях), но ещё и к дублированию действий.

2) "Бутылка Колы".
Сосредоточение на интеграционных тестах, минимальное количество юнит-тестов и E2E тестов. Это может быть полезно для сложных систем с множеством взаимосвязей.

3) "Песочные часы".
В случае, если отсутствуют (или их очень мало) тесты среднего уровня (интеграционные), то пирамида превращается в песочные часы. В такой структуре много сквозных и модульных тестов, но мало интеграционных. Это не так плохо, как в случае с формой мороженого, но всё ещё приводит к слишком большому количеству падений сквозных тестов. В то же время, обнаружить баги приложения, которые приводят к падениям этих тестов, было бы быстрее и проще с помощью среднеуровневых тестов.







====================== МЕТОДЫ ТЕСТИРОВАНИЯ (Black-box, White-box, Gray-box) =====================

В методологии QA (Quality Assurance) есть классификация методов тестирования по прозрачности системы (программы, приложения). 
Она определяется тем, может ли тестировщик видеть код программного обеспечения и работать с ним.

Вот самое простое определение: 
- Тестирование белого ящика базируется на знаниях об устройстве системы. 
- Тестирование черного ящика базируется на знаниях требований к системе.

Тестирование Черного Ящика — это стратегия или метод тестирования, которая базируется только лишь на тестировании по функциональной спецификации и требованиям, 
при этом не смотря во внутреннюю структуру кода и без доступа к базе данных. 
Фактически мы знаем какой должен быть результат при определенном наборе данных, которые подаются на вход.
Нам достаточно знать, что должно быть при таком-то поведении пользователя и при таких-то наборах данных (зависит от специфики проекта).
Результат проверяем с юзер-интерфейса на уровне простого пользователя. 
На данный момент такая стратегия является наиболее часто применима в IT компаниях.
Тестирование черного ящика — это, в первую очередь, проверка того, что продукт соответствует функциональным требованиям. Такое тестирование проводится на основе документации.



