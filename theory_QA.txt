
==================== ЧТО ТАКОЕ ТЕСТИРОВАНИЕ ====================

Тестирование программного обеспечения (Software Testing) - проверка соответствия между реальным и ожидаемым поведением программы, 
осуществляемая на конечном наборе тестов, выбранном определенным образом.
В более широком смысле, тестирование - это одна из техник контроля качества, включающая в себя активности по 
планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).




==================== ЧТО ТАКОЕ КАЧЕСТВО ПО ===================

Качество ПО — это совокупность свойств и характеристик программного обеспечения, которые определяют его способность удовлетворять требованиям и ожиданиям пользователя. 
Оно может быть измерено на основе различных критериев, таких как функциональность, надежность, производительность, удобство использования, безопасность и т.д. 
Качество ПО может быть улучшено с помощью процессов тестирования, анализа, управления изменениями, управления рисками и других методов.




==================== ЦЕЛИ ТЕСТИРОВАНИЯ ====================

Три ключевые цели тестирования:
1. Повысить вероятность того, что разрабатываемое приложение будет работать правильно при любых обстоятельствах.
2. Повысить вероятность того, что разрабатываемое приложение будет соответствовать всем описанным требованиям.
3. Предоставление актуальной информации о состоянии продукта на момент тестирования (предоставление информации 
о статусе готовности заявленной функциональности системы или приложения).

Также можно определить дополнительные цели тестирования:
--> Оценка рисков. Тестирование помогает оценить риски, связанные с продуктом и его функциональностью. 
Это может помочь в принятии решений о дальнейшей разработке и релизе ПО.
--> Улучшение процесса разработки. Тестирование может помочь улучшить процесс разработки ПО. Результаты тестирования могут помочь выявить слабые места в процессе, которые можно улучшить для повышения эффективности и качества разработки.

Результатом тестирования непосредственно для компании разработчика продукта служит сокращение потенциальных дополнительных трат на исправление ошибок в релизной версии и снижение репутационных рисков, ведь любой обнаруженный дефект негативно влияет на доверие пользователей к продукту.



================= Почему важно тестировать программы =================

Тестирование программ является важной практикой по нескольким причинам:
--> Выявление ошибок. Позволяет обнаружить ошибки и недочеты в программном обеспечении. Раннее обнаружение и исправление ошибок способствует улучшению качества программы и уменьшению возможных проблем и рисков в дальнейшем.
--> Гарантия качества. Помогает проверить, насколько программа соответствует своим требованиям и спецификациям. Это позволяет удостовериться, что программа работает правильно, выполняет задачи и доставляет ожидаемые результаты.
--> Улучшение надежности. Способствует повышению надежности программного обеспечения. Через тестирование можно выявить уязвимости, ошибки в обработке данных и другие проблемы, которые могут привести к сбоям или неправильной работе программы.
--> Оптимизация производительности. Позволяет оценить производительность программы, выявить узкие места и бутылочные горлышки, которые могут замедлять работу программы.
--> Повышение удовлетворенности пользователей. Позволяет выявить и исправить проблемы, которые могут негативно влиять на пользовательский опыт. Корректная и надежная работа программы улучшает удовлетворенность пользователей и способствует их лояльности.
--> Уменьшение рисков и затрат. Помогает снизить риски, связанные с неправильной работой программы. Обнаружение и устранение ошибок на ранних стадиях разработки экономит время, усилия и ресурсы, которые могут быть затрачены на исправление проблем в более поздних этапах.

В целом, тестирование программ позволяет обеспечить высокое качество программного обеспечения, минимизировать риски и повысить доверие пользователей.



===================== BUG REPORT ========================

Баг-репорт (bug report) — это технический документ, который подробно описывает ошибку в работе программы, приложения или другого ПО. Его составляет тестировщик, чтобы разработчикам было понятно, что работает неправильно, насколько дефект критичен и что нужно исправить.
Баг репорт (bug report) – это документ, содержащий отчет о любом недостатке в компоненте или системе, который может привести компонент или систему к невозможности выполнить требуемую функцию.
Bugreport c определением в самом общем случае – это несоответствие требованиям или функциональным спецификациям (или здравому смыслу). То есть это отклонение фактического результата (actual result) от ожидаемого результата (expected result).

Bug report (перевод с англ.) – отчёт о дефекте.

	ID (идентификатор проблемы)
	Project (Название проекта)
	Component (Компонент приложения)
	Version (Номер версии) 
	Issue Type (Тип проблемы)
!!! Summary/Title (Краткое описание)
!!! Severity (Серьёзность)  (отражает технический аспект дефекта)
	Priority* (Приоритет)   (отражает коммерческий аспект дефекта)
	Status (Статус) 
	Precondition (Предусловия)
	Environment (Окружение: ОС, браузер + версия, ...)
	Reporter (Автор, кто открыл)
	Assigned to* (На кого назначен)
!!! STR (Шаги к воспроизведению)
!!! Actual Results (Фактический результат)
!!! Expected Results (Ожидаемый результат)
	Attachment (прикрепленные материалы: скриншоты; видео – скринкасты; логи и т.д.)

	!!! --> обязательные поля.
	*   --> заполняет менеджер проекта.


Описание (Description) – также чрезвычайно важный атрибут. Описание должно быть лаконичным и ясным, как и Summary, но в более развернутой форме. Если есть альтернативные шаги, то их также нужно указать. В описание можно оставлять любые полезные примечания – повторяемость, уточнения и т.п.

Описание (Description) имеет набор атрибутов, которые входят в его состав:
--> Шаги воспроизведения (Steps to Reproduce) – данная информация в отчёте об ошибке является крайне важной. Именно она позволяет разработчику быстро воспроизвести и устранить проблему. Это поле следует заполнять максимально подробно, т.к. будучи незнакомым с внутренней структурой приложения, тестировщик не может знать, какие из выполненных им действий наиболее существенны для диагностирования данной ошибки (steps в тест-кейсе, в какой-то степени, похожи на STR).
--> Фактический Результат (Actual Result)
--> Ожидаемый результат (Expected Result)
--> Прикрепленные файлы (Attachment) – любая информация, которая поможет воспроизвести ситуацию: логи, скриншоты, видео и т.п.
--> Воспроизводимость (Reproducibility) – это поле показывает, воспроизводится ли баг всегда («always») или лишь иногда («sometimes»). Баги, воспроизводящиеся всегда, гораздо проще диагностировать.
--> Возможность «обойти баг» (Workaround) – это поле косвенно влияет на важность и срочность устранения ошибка.
Если некое действие можно выполнить в обход сценария, приводящего к ошибке, поле принимает значение «да» («yes»), в противном случае – поле принимает значение «нет» («no»).


Пример Description в баг репорте:
Если администратор заходит на страницу приветствия, то логотип пропадает.
Actual result: логотипа нет. (Реальный результат)
Expected result: логотип в правом верхнем углу. (Ожидаемый результат)
Requirement ID: #45 (пункт требований)
Reproduced on: Win10, IE11, 1200x800dpi (на чем воспроизводится)
Reproducibility: sometimes.
Workaround: Да, логотип отображается, если обновить страницу повторно.
For more details, please, see attached files: …


Каких правил придерживаться при написании баг-репорта?
-> Правило №1: следуйте принципу «1 дефект = 1 баг-репорт». Это позволит сохранить прозрачность процессов на проекте и детально следить за исправлением недочётов.
-> Правило №2: пишите баг-репорт простым и лаконичным языком, ведь от того, насколько быстро разработчик поймёт суть проблемы зависит скорость внесения правок в код.
-> Правило №3: описывайте дефект кратко, но с сохранением максимума полезной информации.
-> Правило №4: удостоверьтесь в воспроизводимости ошибки до заведения баг-репорта, повторите свой алгоритм действий и по возможности сократите число шагов.
-> Правило №5: проверьте, нет ли идентичного дефекта, который уже был зафиксирован.


================= СЕРЬЁЗНОСТЬ и ПРИОРИТЕТ БАГА ================

У бага есть два важных атрибута — приоритет и серьёзность.

Серьезность (Severity) - это атрибут, характеризующий влияние дефекта на работоспособность приложения. 
Серьёзность показывает, насколько баг влияет на возможность работать в программе. Обычно выделяют 5 уровней серьёзности бага. Самый опасный — блокирующий баг. Например, мобильное приложение перестало загружаться, и пользователь видит пустой экран. Самый безвредный — тривиальный баг. Он не влияет на работу приложения, а многие пользователи его даже не заметят. Это может быть, например, опечатка в разделе меню, куда редко заходят.

По степени влияния на систему серьёзность бага бывает следующих видов:
--> S1 — Блокирующая (Blocker). Приложение не запускается ни на одном устройстве или выдаёт ошибку при загрузке.
Пример: приложение не открывается, поэтому невозможно сделать покупку.
--> S2 — Критическая (Critical). Часть функционала не работает, но это не блокирует процесс.
Пример: Скидка по купону не работает, но товар всё равно можно купить без скидки.
--> S3 — Значительная (Major). Часть логики работает некорректно, но пользователь может решить проблему другим способом.
Пример: поиск в приложении не выдаёт нужный товар, но его можно найти, если искать по брендам.
--> S4 — Незначительная (Minor). Не нарушает логику приложения.
Пример: кнопка «Купить» уехала за экран и видна только наполовину.
--> S5 — Тривиальная (Trivial). Не относится к логике приложения и не влияет на общее качество продукта.
Пример: малозаметная опечатка в меню.


Приоритет (Priority) - это атрибут, указывающий на очередность выполнения задачи или устранения дефекта. 
Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект.
Приоритет — это критерий, который показывает, насколько быстро нужно исправить дефект. С точки зрения функционала баг может быть несерьёзный, но при этом важный для бизнеса. Обычно выделяют три приоритета:

---> P1 Высокий (High) — исправить в первую очередь. 
Ошибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.

---> P2 Средний (Medium) — исправить, когда разобрались с первой категорией багов.
Ошибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.

---> P3 Низкий (Low) — исправить, когда разобрались с багами других приоритетов.
Ошибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.


На проектах редко используют оба атрибута — в основном объединяют приоритет и серьёзность, или выбирают что-то одно. Чаще всего это приоритет — с точки зрения планирования важно понимать, что исправлять в первую очередь, а что может подождать.
Также в разных проектах названия и количество приоритетов могут отличаться. Например, в списке приоритетов бага в Jira могут быть такие приоритеты: Блокирующий (самый опасный), Критический, Важный, Нулевой (самый безобидный).





================= ЖИЗНЕННЫЙ ЦИКЛ БАГА ================

Жизненный цикл бага (bug life cycle) - это этапы, которые проходит баг от создания до закрытия.
Каждый этап работы с багом обозначается в баг-трекинговой системе как "Status". Статус показывает, какая работа ведётся над багом в данный момент.
Жизненный цикл бага может содержать следующие стадии:

--> Открыт/Новый (Opened/New) — тестировщик выявил баг и добавил в репорт. Этот статус присваивается автоматически.
--> В работе (In Progress) — о баге сообщили исполнителю (чаще всего разработчику), и он занимается исправлением.
--> Исправлен (Fixed/Resolved) - когда разработчик внесет необходимые правки в код и проверит изменения, он может поменять статус бага на “Исправлен”.
--> Готов к повторной проверке/тестированию (Ready for check/test) — как только дефект исправлен, разработчик передает код на повторное тестирование. Поскольку на этом этапе тестировщик еще не завершил тестирование, присваивается статус “Ожидает повторного тестирования”.
--> Повторное тестирование (Retest) - тестировщик проводит повторное тестирование кода, чтобы проверить, исправлен ли дефект разработчиком, и меняет статус на “Повторное тестирование”. После стадии Retest может быть
два варианта:

1) Закрыт (Closed) — если бага больше не существует, тестировщик присваивает ему статус “Закрыт” (баг устранен и больше не воспроизводится).
2) Повторное открыт (ReOpened) - если после внесенных разработчиком исправлений баг НЕ исчез, тестировщик меняет его статус на “Повторно открыт”. После этого баг снова проходит через весь жизненный цикл.

Кроме основных есть еще несколько статусов:
-> Отклонен (Rejected) — исправлению бага помешала ошибка в репорте, например неверный алгоритм в пункте «Шаги к воспроизведению».
-> Отсрочен (Deferred) — баг признан неприоритетным и исправление переносится.
-> Дубликат (Duplicate) - если дефект повторяется дважды или соответствует концепции другого бага, ему присваивается статус “Дубликат”.
-> Не баг (Not a Bug) - если баг не влияет на функциональность приложения, то ему присваивается статус “Не баг”.



===================== VERIFICATION and VALIDATION ========================

Verification (Верификация) - это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, требованиям, сформированным в начале этого этапа.
Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определённые в начале текущей фазы.
Верификация - это проверки, выполняемые в процессе разработки ПО для ответа на вопрос: “правильно ли мы разрабатываем продукт?”. Это в т.ч. включает проверку документации: requirements specification, design documents, database table design, ER diagrams, test cases, traceability matrix и т.д. Верификация гарантирует, что ПО разрабатывается в соответствии со стандартами и процессами организации, полагаясь на reviews и статические методы тестирования (т.е. без запуска ПО, но, например, с unit/integration tests). 
Верификация является превентивным подходом (Preventative approach).
Верификация - это подтверждение путем представления объективных доказательств выполнения данным рабочим элементом установленных требований. (ГОСТ 56920)


Validation (Валидация) - это определение соответствия разрабатываемого ПО ожиданиям и потребностям заказчика (пользователя), его требованиям к системе.
Валидация - это процесс оценки конечного продукта, чтобы проверить, соответствует ли он потребностям бизнеса и ожиданиям клиентов, т.е. отвечает на вопрос: “правильный ли мы разработали продукт?”. Валидация является динамическим тестированием, т.е. происходит с помощью выполнения кода и прогона тестов на нём (UAT/CAT, usability, всё что угодно). 
Валидация является реактивным подходом (Reactive approach).
Валидация демонстрирует, что рабочий элемент может использоваться пользователями для решения определенных ими задач. (ГОСТ 56920)


Если попробовать привести очень упрощенный пример, представим блюдо в ресторане. Верификация будет включать проверку технологической карты, оценку процесса приготовления (температуры, времени и т.п.). На протяжении этого процесса можно будет примерно быть уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его приготовим. Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.



---------- Идентификация, аутентификация и авторизация ----------

Идентификация, аутентификация и авторизация – три процесса защищающие Ваши данные или денежные средства от доступа посторонних лиц.

1) Идентификация (Identification) — процесс распознавания пользователя по его идентификатору.
2) Аутентификация (Authentication) — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает.
3) Авторизация (Authorisation) — предоставление определённых прав.


Рассмотрим на примере с доступом в онлайн-банкинг. Каждое действие пользователя и системы рассмотрим подробно.
--------- Идентификация ---------
Находясь на сайте банка, пользователь решает зайти в личный кабинет, чтобы сделать денежный перевод. На странице личного кабинета система вначале просит ввести идентификатор. Это может быть логин, имя и фамилия, адрес электронной почты или номер мобильного телефона.
Какой конкретно вид данных необходимо ввести – зависит от ресурса. Данные, которые указывались при регистрации, необходимо ввести для получения доступа. Если при регистрации указывалось несколько типов данных – и логин, и адрес электронной почты, и номер мобильного, то система сама подскажет что ей конкретно нужно.
Ввод этих данных необходим для идентификации человека за монитором как пользователя конкретно этого банка.
Если пользователь в качестве идентификатора ввел «Александр Петров», и система нашла в своей базе запись о пользователе с таким именем, то идентификация завершилась.

--------- Аутентификация ---------
После идентификации следует процесс аутентификации, в котором пользователю нужно доказать, что он является человеком, который регистрировался под именем Александр Петров.
Для доказательства необходимо наличие одного из типов аутентификационных данных:
-> Нечто, присущее только пользователю. Биометрические данные: сканеры лица, отпечатки пальцев или сетчатки глаза.
-> Нечто, известное только пользователю. Сюда относятся pin-коды, пароли, графические ключи, секретные слова.
-> Нечто, имеющееся у пользователя. В данном качестве может выступать токен, то есть компактное устройство, предназначенное для обеспечения информационной безопасности пользователя, также используется для идентификации владельца. Самые простые токены не требуют физического подключения к компьютеру – у них имеется дисплей, где отображается число, которое пользователь вводит в систему для осуществления входа; более сложные подключаются к компьютерам посредством USB и Bluetooth-интерфейсов.
Самый распространенный тип аутентификационных данных – это пароль. Именно поэтому так важно создавать и правильно хранить свои пароли.
После ввода пользователем пароля система проверяет: соответствует ли условный пароль «Q45fp02@13» пользователю с именем Александр Петров. Таким образом происходит аутентификация.

Аутентификация бывает одно-, двух- и трёхфакторной.
- Однофакторная аутентификация требует подтверждения только одним способом — например, с помощью пароля. Она встречается чаще всего.
- Двухфакторная аутентификация используется в системах, которые хранят важные или личные данные. Например, в банковских приложениях или в социальных сетях. При входе в соцсеть у пользователя могут попросить не только пароль, но и другую информацию — код из СМС или биометрические данные.
- Трёхфакторная аутентификация - встречается в системах с повышенными требованиями к безопасности — например, в банковской сфере. Третьим фактором, позволяющим подтвердить личность, могут быть электронные ключи доступа. Электронный ключ хранится на специальном USB-накопителе и подключается в момент подтверждения доступа.

--------- Авторизация ---------
Если все верно, и пара логин-пароль верны, то система предоставит пользователю доступ к его ресурсам и совершение банковских операций, то есть произойдет авторизация. Авторизация определяет набор привилегий и прав, доступных конкретному пользователю. Например, открывает доступ к просмотру баланса иили совершению денежных переводов.

Описанные процессы всегда происходят только в таком порядке: идентификация, аутентификация, авторизация. Вся цепочка потеряет смысл, если, например, сайт сначала предоставит доступ к денежным средствам пользователя, а потом будет уточнять, он ли это на самом деле.
Процессы идентификации, аутентификации и авторизации характерны не только для онлайн-банкинга, но и для электронной почты, социальных сетей и других ресурсов.




------------- QA, QC, Testing – в чем разница -------------

TESTING (тестирование) – представляет собой проверку создаваемого программного продукта на соответствие требованиям к этому продукту. Основная задача тестирования – это выявить и зафиксировать дефекты. Т.е. это проверка какого-то функционала и поиск в нём багов (по уже составленным чек-листам и тест-кейсам).
-> Суть: Detection (англ.) – обнаружение, выявление, диагностика.
-> Фокус направлен на исходный код и дизайн программного обеспечения.
-> Проводится на стадии тестирования и в процессе разработки ПО.

QUALITY CONTROL (контроль качества) – более обширное понятие, сюда входит не только поиск багов, но и анализ этих багов, анализ результатов тестирования. Предоставление отчетности, готовность к релизу, апдейт чек-листов, составление отчета о качестве продукта перед релизом, что нет критических багов. Соответствует ли это ПО требованиям заказчика, спецификациям, ТЗ и т.д. Можно ли выкатывать продукт в продакшен. Работает с двумя понятиями – верификацией и валидацией, т.е. отвечает на вопросы: 
1) правильно ли мы делаем наше программное обеспечение (verification);
2) правильное ли программное обеспечение мы делаем (validation).
-> Суть: Verification/Validation (англ.) - проверка/подтверждение.
-> Фокус направлен на продукт.
-> Проводится перед выпуском продукта.


QUALITY ASSURANCE (гарантия качества, обеспечение качества, убеждённость в качестве) – поиск решений для того, чтобы баги не появлялись. 
Главная задача QA – это не поиск багов в готовом ПО, а bugs-prevention (профилактика). Т.е. основная задача QA-отдела – это уменьшить количество багов, предотвратить их появление в принципе. 
В QA-отдел могут входят не только тестировщики и QA-инженеры, но также BA, PM. 
QA-отдел начинает свою работу ещё тогда, когда нет ПО; его главная задача – определиться, как построить работу для того, чтобы багов было меньше.
QA-инженер составляет тест план, методологии, выбирает техники тест-дизайна, составляется документация, осуществляет помощь в составлении требований и чекинг требований (из созвона).
-> Prevention (англ.) – профилактика, предупреждение, предотвращение, недопущение.
-> Фокус направлен на процессы.
-> Проводится на всех этапах жизненного цикла разработки ПО.



----------- ЖИЗНЕННЫЙ ЦИКЛ РАЗРАБОТКИ ПО (SDLC) -------------

SDLC (software development life cycle) начинается в момент принятия решения о том, что нам нужно какое-то ПО и заканчивается в момент вывода этого ПО из эксплуатации.
--> 0. Idea;
--> I. Сбор и анализ требований (какие проблемы требуют решений? Что хочет от нас заказчик?) Работают SA (system analyst), BA, PM, PO (product owner);
--> II. Архитектура и дизайн (Каким образом мы это сделаем?).
--> III. Разработка (Регулирует процесс создания продукта). *требования могут меняться на этапе разработки, если что-то не учли на этапе проектирования и дизайна.
--> IV. Тестирование (тестировщики используют продукт, сделанный на этапе разработки и пытаются сопоставить его с теми требованиями, которые были собраны на первом этапе). 
--> V. Релиз (Продукт доступен всем конечным пользователям) *они могут зайти на сайт или скачать приложение или оплатить что-то и т.д.
--> VI. Поддержка (Maintenance, Support) (чинятся баги, дописываются новые фичи, изменяются существующие функциональности, осуществляется поддержка пользователей).
Поддержку можно представить как повторяющуюся цепочку шагов:
«Определение новых требований» --> «Разработка» --> «Тестирование» --> «Развертывание».

--> Вывод из эксплуатации (смерть проекта). 
Закрытие – последний этап жизни ПО. На нем происходит вывод продукта из эксплуатации, его замена на современные аналоги, либо новые версии.
Как пример, можно вспомнить браузер Internet Explorer (был замен на Edge).


----------- ЖИЗНЕННЫЙ ЦИКЛ ТЕСТИРОВАНИЯ ПО (STLC) -------------

STLC (Software Testing Lifecycle) - это процесс тестирования, который включает в себя определенную последовательность шагов, чтобы гарантировать достижение целей в области качества. В процессе STLC каждое действие выполняется планомерно и систематически. Каждый этап имеет разные цели и результаты. У разных организаций разные этапы STLC, однако основа остается прежней.
STLC имеет несколько взаимосвязанных фаз и в целом очень похож на SDLC. Эти фазы являются последовательными и называются:

1) Анализ требований (Requirement Analysis): один из важнейших этапов, потому что именно на нем можно почти бесплатно исправить недостатки проекта. Этап анализа требований также определяет потенциальную потребность в автоматизированном тестировании и позволяет производить экономические расчеты затрат на рабочую силу на основе оценки проекта. На этом же этапе обсуждаются и документируются критерии начала и окончания тестирования.

2) Планирование тестирования (Test Planning): на этом этапе формируется план тестирования, т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования (участники и их роли, инструменты, окружение). 
Во время планирования мы также пытаемся определить метрики, метод сбора и отслеживания этих метрик. 
План составляют исходя из требований, тестовой стратегии и анализа рисков.

3) Разработка тест-кейсов (Test Case Development): на этом этапе команда создает тест-кейсы, которые описывают шаги, необходимые для тестирования программного обеспечения. Тесты должны покрывать все возможные сценарии, чтобы найти как можно больше проблем и ошибок в программе. Качество и эффективность тест-кейсов, разработанных на этом этапе, играют жизненно важную роль для успешного тестирования.

На этапе разработки тест-кейсов выполняются следующие действия:
-> Определение тест-кейсов для разработки.
-> Создание простых и понятных тест-кейсов.
-> Определение ожидаемых результатов для каждого тест-кейса.
-> Проверка и валидация тест-кейсов.

По завершении этого этапа команда тестирования должна иметь набор тест-кейсов, которые помогают проверить все функциональности и возможности программного обеспечения. Это гарантирует, что все проблемы будут обнаружены и исправлены до релиза ПО.


4) Настройка тестовой среды (Test Environment Setup).
Для выполнения разработанных тестовых сценариев необходимо создать условия подходящего тестового окружения, такие как серверы, платформы, аппаратное и программное обеспечение. Важно, чтобы тестовая среда охватывала все среды, в которых будет работать пользователь.
На этом этапе STLC настраиваются операционные системы и виртуальные машины, развертываются инструменты тестирования, такие как Selenium, Katalon Studio, а также тестовая среда и базы данных проекта. Мы также обращаемся с запросами к DevOps и администраторам, если требуется поддержка.

Например, некоторые функции, работающие в Google Chrome, не работают в Microsoft Edge. Функция может без проблем запускаться с 16 ГБ ОЗУ, но может создавать проблемы с 4 ГБ ОЗУ. Основным результатом этого этапа является готовая стратегия управления тестовыми средами.

На этом этапе:
--> определяется программное и аппаратное обеспечение, необходимое для разных уровней производительности;
--> расставляются приоритеты тестовых сред;
--> проводится настройка тестовых сред;


5) Выполнение тестов (Test Execution): тесты выполняются на основе готовой тестовой документации и правильно настроенной тестовой среды. Все результаты тестирования регистрируются в Системе управления тестированием (TMS). Отрицательно пройденные тесты, в которых фактический результат отличается от ожидаемого, регистрируются как ошибки и передаются команде разработчиков на доработку с последующей перепроверкой после исправления.
Как только команда разработчиков устраняет ошибку, начинается повторное (регрессионное) тестирование ПО. Все функции важно снова проверить, потому что исправление ошибки может привести к возникновению новых проблем в другом модуле решения. Какие конкретно существуют этапы тестирования — зависит от специфики проекта и проводимых видов тестов.

Результатом данного этапа считается отчёт по качеству с результатами тестирования. Он составляется командой тестирования и отправляется заказчику с оговоренной периодичностью.

6) Завершение цикла испытаний (Test Cycle Closure): 
Окончание тестирования и выпуск конечного продукта (выход в релиз) знаменуют начало фазы завершения тестирования. На этом этапе выполняется окончательная генерация отчетов о тестировании для клиента. 
Они должны включать затраченное время, процент обнаруженных ошибок и положительных результатов тестирования, общее количество обнаруженных и исправленных ошибок. 
Что касается отдела тестирования, то это момент для анализа его работы, подведения итогов, анализа его продуктивности и возможности внести предложения по улучшению качества тестирования.




-------------- Матрица трассировки -------------

Матрица трассируемости (RTM - Requirement Traceability Matrix) - двумерная таблица, описывающая связь двух сущностей (например, требований и тестовых сценариев). Таблица позволяет производить прямую и обратную трассировку от одной сущности к другой, обеспечивая таким образом возможность определения покрытия и оценки влияния предполагаемых изменений. (ISTQB)

Матрица трассируемости (Requirement Traceability Matrix AKA Traceability Matrix or Cross Reference Matrix) используется для документирования связей между требованиями и тест-кейсами по этим требованиям и наглядного отображения трассируемости в виде простой таблицы.
Матрица трассируемости может служить одновременно в качестве матрицы покрытия. Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет.


-------------- Что такое плавающий баг? -------------

Нежелательное поведение программы, которое возникает спонтанно и непредсказуемо, называют плавающим багом, или гейзенбагом (с отсылкой к немецкому физику Вернеру Карлу Гейзенбергу – автору принципа неопределенности из квантовой физики). Загадочное поведение программы, которое невозможно воспроизвести или зафиксировать – одно из самых сложных явлений в работе инженеров по QA. Обнаружить, поймать и превратить в обычный – схема охоты на плавающий баг. Говорят, будто плавающие баги есть в любой программе, просто некоторые из них еще ни разу не проявились.


-------------- Что такое тест-кейс (Test case) -------------

1) Тестовый сценарий (test case) - набор входных значений, предусловий выполнения, ожидаемых результатов и постусловий выполнения, разработанный для определенной цели или тестового условия, таких как выполнения определенного пути программы или же для проверки соответствия определенному требованию. (IEEE 610)

2) Test case (тест-кейс, тестовый пример/случай) - это артефакт, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или ее части. Более строго - формализованное описание одной показательной проверки на соответствие требованиям прямым или косвенным.

Часто тест-кейсы делят на две категории:
--> Высокоуровневый тест-кейс (high level test case или logical test case) - тест-кейс без конкретных входных данных и ожидаемых результатов. Как правило, ограничивается общими идеями и операциями, схож по своей сути с подробно описанным пунктом чек-листа. Достаточно часто встречается в интеграционном тестировании и системном тестировании, а также на уровне smoke. Может служить отправной точкой для проведения исследовательского тестирования или для создания низкоуровневых тест-кейсов.
--> Низкоуровневый тест-кейс (low level test case) - тест-кейс с конкретными входными данными и ожидаемыми результатами. Представляет собой «полностью готовый к выполнению» тест-кейс и вообще является наиболее классическим видом тест-кейсов. 
Начинающих тестировщиков чаще всего учат писать именно такие тесты, т.к. прописать все данные подробно - намного проще, чем понять, какой информацией можно пренебречь, при этом не снизив ценность тест-кейса.



------ Содержание тест-кейса: ------
- Идентификатор набора тестов (Test Suite ID): Идентификатор набора тестов, в которых входит этот кейс;
- Идентификатор тестового кейса (Test Case ID): Идентификатор самого кейса;
- Заголовок кейса (Test Case Summary): Краткое и емкое название проводимой проверки;
- Связанное требование (Related Requirement): Идентификатор требования, к которому относится / отслеживается данный тестовый пример;
- Предусловия (Preconditions): действия, которые нужно выполнить, прежде чем приступать к тест-кейсу, а также настройки приложения и тестовой среды. Например, пройти авторизацию для пользователя с правами администратора. При необходимости здесь могут указываться учетные данные.
- Шаги выполнения (Test Script/Procedure): Шаги выполнения теста;
- Постусловия (Postconditions) — список действий, возвращающих систему в исходное состояние (указывается при необходимости).
- Ожидаемый результат (Expected Result): результат, который мы ожидаем получить после выполнения шагов теста;
- Статус (Status) — обозначает результат исполнения тест-кейса или причину, по которой он не может быть исполнен. Success (успех), Failed (провал), Blocked (блокировка) (указывается при необходимости).
- Тестовое окружение (Test Environment): оборудование / программное обеспечение / сеть, в которых выполнялся тест, т.е. все необходимые сведения об окружении, чтобы можно было воспроизвести полученный результат.

------ Опциональные атрибуты тест-кейса: ------
- Заметки (Remarks): Любые комментарии к тесту или выполнению теста;
- Создано (Created By): Имя автора тестового примера;
- Дата создания (Date of Creation): Дата создания тестового примера;
- Выполнено (Executed By): Имя человека, выполнившего тест;
- Дата выполнения (Date of Execution): Дата выполнения теста;




------------ Обязательные атрибуты тест-кейса ------------

У тест-кейса есть обязательные атрибуты, которые должны быть заполнены.
Обязательными атрибутами тест-кейса являются:
1) Номер/идентификатор тест-кейса (Test Case ID) — как правило, присваивается автоматически, зависит от особенностей проекта, может содержать зашифрованные данные о требовании, которое он проверяет, а также другую информацию, представленную в числовом виде.
2) Название тест-кейса (Test Case Title/Summary) - краткое описание сценария, который проверяет данный тест-кейс.
* 3) Предварительные шаги —  описание действий, которые необходимо выполнить, но прямого отношения к проверке они не имеют (например, зарегистрироваться в системе для проверки создания элемента). 
* - Если предварительных шагов нет, то секция НЕ заполняется.
4) Шаги для выполнения тест-кейса (Steps) - порядок действий, чтобы проверить работу функции или выполнение сценария.
5) Ожидаемый результат (Expected Result) — как должна вести себя система после определённых действий.



------------ Пример тест-кейса ------------
Тест-кейс № 1.            ----- (ID)
Создание жильца без ФИО.  ----- (Title)

Шаги:                     
1. Зайти на сайт www.dev_test.ru (логин — test, пароль — test).
2. Войти под учеткой администратора (логин — admin, пароль — 1)
3. Перейти на вкладку «Жильцы».
4. Нажать на кнопку «Создать карточку жильца».
5. Нажать на кнопку «Сохранить», не заполняя никакие данные.

Ожидаемый результат:
Появляется сообщение об ошибке «Заполните обязательные поля, отмеченные * », карточка не сохраняется.




------------------ Чек-лист -------------------

Чек-лист (checklist) - это документ, содержащий набор идей по тестированию.
- Оформляется в виде списка проверок;
- Содержит только идею проверки, без детальных инструкций.

Обязательные атрибуты чек-листа:
1) Номер проверки
2) Тест (название проверки)
3) Статус (Результат проверки) (Passed/Failed)
4) Комментарий (обычно содержит ссылку на багрепорт)

Статусы могут быть разными. Например:
- passed — пройдено;
- failed — неудачно;
- blocked — заблокировано;
- skipped — пропущено;
- not run — не работает.

Опциональные атрибуты чек-листа:
5) Ожидаемый результат
6) Шаги 
и др. (но это уже больше похоже на тест-кейс)


Чек-лист в тестировании устроен просто. Обычно он имеет табличную форму, где в каждой строке описана задача, которую нужно выполнить, а напротив каждой задачи есть ячейка для записи ее статуса. 
Например:
______________________________________________________
    Выполняемая задача     |  Статус   |  Комментарии |
---------------------------|-----------|--------------|
Регистрация по e-mail      |  Passed   |              | 
Регистрация через Facebook |  Passed   |              |
Регистрация через VK       |  Failed   |   bug#126    |
-------------------------------------------------------



--------------- УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels) в Тестировании ПО ---------------

Acceptance Testing
      ↑
System Testing
      ↑
Integration Testing
      ↑
Module/Unit/Component testing


---------- Модульное/юнит/компонентное тестирование -----------

Компонент (component) - наименьший элемент программного обеспечения, который может быть протестирован отдельно.
Компонентное тестирование (component testing) - тестирование отдельных компонентов программного обеспечения.

Модульное тестирование (оно же юнит-тестирование) используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. 
Очевидно, что это тестирование методом БЕЛОГО ящика и чаще всего оно проводится самими разработчиками.
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов.

Компонентное тестирование - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который проводится командой QA.


---------- Интеграционное тестирование (Integration testing) -----------

Интеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами).
Смысл интеграционного тестирования заключается в процессе тестирования интерфейсов между двумя компонентами или программными модулями для оценки того, как данные передаются между ними.
Интеграционное тестирование обычно проводится после модульного тестирования, которое включает в себя тестирование отдельных модулей и блоков. 
После того, как установлено, что каждый блок работает изолированно, интеграционное тестирование оценивает, как эти блоки работают при объединении.

Зачем нужно интеграционное тестирование:
— Разные разработчики используют разную логику при разработке модулей даже для одного и того же программного приложения. Интеграционное тестирование — это единственный способ убедиться, что отдельные модули работают вместе так, как должны.
— Когда данные переходят от одного модуля к другому, структура этих данных может измениться, а некоторые значения могут быть удалены. Это может вызвать значительные проблемы в работе модулей.
— Модули взаимодействуют со сторонними инструментами и API. Важно протестировать интеграцию, чтобы убедиться, что данные, принимаемые API или сторонним инструментом, корректны, а генерируемые ответы также соответствуют ожиданиям.
— Если разработчик внедряет изменения без модульного тестирования, интеграционное тестирование необходимо для оценки эффективности изменений.

Уровни интеграционного тестирования:
- Компонентный интеграционный уровень (Component Integration testing)
Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
- Системный интеграционный уровень (System Integration Testing)
Проверяется взаимодействие между разными системами после проведения системного тестирования.

Подходы к интеграционному тестированию:
1) Подход большой взрыв ("Big Bang" Integration).
Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.

2) Инкрементальный подход (Incremental Approach).
При таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. Осуществляется разными методами:

- Сверху вниз (нисходящий подход) (Top-Down Integration)
Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.

- Снизу вверх (восходящий подход) (Bottom-Up Integration)
Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. 
Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения.

- Гибридный/сэндвич-подход (Sandwich/Hybrid Approach)
Представляет собой комбинацию восходящего и нисходящего подходов. Здесь целью является средний слой, в то время как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны.



---------- Системное тестирование (System Testing) -----------

Системное тестирование означает тестирование всей системы в целом, оно выполняется после интеграционного тестирования, чтобы проверить, работает ли вся система целиком должным образом. 
В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.
Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом.
Для минимизации рисков, связанных с особенностями поведения системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.


Можно выделить два подхода к системному тестированию:
--> на базе требований (requirements based)
Для каждого требования пишутся тестовые случаи (test cases), проверяющие выполнение данного требования.
--> на базе случаев использования (use case based)
На основе представления о способах использования продукта создаются случаи использования системы (Use Cases). 
По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария пишутся тест кейсы (test cases), которые должны быть протестированы.



---------- Приемочное тестирование (Acceptance testing - AT) -----------

Приемочное тестирование – это комплексное тестирование, необходимое для определения уровня готовности системы к последующей эксплуатации. Тестирование проводится на основании набора тестовых сценариев, покрывающих основные бизнес-операции системы.

Приемочное тестирование (Acceptance Testing) - формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:
- определения удовлетворяет ли система приемочным критериям;
- вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.

Приемочное тестирование выполняется на основании набора типичных тестовых случаев и сценариев, разработанных на основании требований к данному приложению.

Решение о проведении приемочного тестирования принимается, когда:
- продукт достиг необходимого уровня качества;
- заказчик ознакомлен с Планом Приемочных Работ (Product Acceptance Plan) или иным документом, где описан набор действий, связанных с проведением приемочного тестирования, дата проведения, ответственные и т.д.

Виды приемочного тестирования:
1) Пользовательское приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям.
2) Бизнес - приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам.
3) Правовое приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается.
4) Операционное тестирование (OAT - Operational Acceptance testing) проводится с целью убедиться, что система выполняет свою роль в среде эксплуатации согласно бизнес-модели. Данный вид тестирования проводится до пользовательского приемочного тестирования.
Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment).
5) Альфа-тестирование (Alpha Testing) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. Альфа-тестирование часто используется как форма внутреннего приемочного тестирования перед проведением бета-тестирования.
6) Бета-тестирование, полевые испытания (Beta Testing, Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде.
Бета-тестирование проводится после альфа-тестирования и может использоваться как приемочное тестирование внешними пользователями. Бета-версия системы передается группе пользователей вне команды разработки, чтобы снизить количество дефектов. Иногда версия передается нескольким командам, чтобы получить обратную связь от как можно большего количества будущих пользователей.



------------- Критерии начала и окончания тестирования (protesting) -------------

Критерии начала тестирования:
- готовность тестовой платформы (тестового стенда)
- законченность разработки требуемого функционала
- наличие всей необходимой документации

Критерии окончания тестирования:
- результаты тестирования удовлетворяют критериям качества продукта:
  1. требования к количеству открытых багов выполнены
  2. выдержка определенного периода без изменения исходного кода приложения Code Freeze (CF)
  3. выдержка определенного периода без открытия новых багов Zero Bug Bounce (ZBB)
  


------------ Пирамида тестирования ------------

Пирамида тестирования — это концептуальная модель, которая помогает организовать различные виды тестов в процессе разработки программного обеспечения. Она представляет собой пирамиду, разделенную на уровни, каждый из которых соответствует определенному типу тестирования: от юнит-тестов на нижнем уровне до интеграционных и системных тестов на верхних уровнях. Эта модель помогает разработчикам и тестировщикам понять, какие тесты нужно проводить в большем объеме и на каких этапах разработки.
Пирамида тестирования — это абстракция, которая показывает соотношение видов тестов приложения. 
Основная цель пирамиды — помочь обнаруживать баги на ранних стадиях, когда их исправление значительно дешевле, чем на поздних.
Пирамида тестов — это абстракция, которая отражает группировку тестов программного обеспечения по разным уровням детализации. Также она характеризует относительное количество тестов в каждой группе.
Пирамида тестирования показывает, как выстраивать тесты на проекте. В большинстве случаев должно быть много юнит-тестов, меньше интеграционных тестов и еще меньше системных тестов.

Ключевые утверждения, которые справедливы для пирамиды:
- Наибольший объем тестов должен быть сконцентрирован на нижних уровнях.
- Чем выше поднимаемся по пирамиде, тем дороже и медленнее будут тесты.
- Тяжелых Е2Е-тестов должно быть минимальное количество.
- В построении пирамиды должны участвовать и разработчики, и тестировщики.

Пирамида тестирования в классическом варианте выглядит следующим образом:

    E2E/UI
      ↑
  Integration 
      ↑
     Unit 

 
Можно сказать, что разработка ПО - это движение по пирамиде снизу вверх. Важно отметить:

1) Тест (ручной, на высоких уровнях, или автотест, на низких уровнях), должен быть на том же уровне, что и тестируемый объект. Например, модульный тест (проверяющий функции, классы, объекты и т.п.) должен быть на компонентном уровне. Это неправильно, если на приемочном уровне запускается тест, который проверят минимальную единицу кода.
2)Тесты уровнем выше не проверяют логику тестов уровнем/уровнями ниже.
3)Чем выше тесты уровнем, тем они:
	- сложней в реализации, и соответственно, дороже в реализации;
	- важнее для бизнеса и критичней для пользователей;
	- замедляют скорость прохождения тестовых наборов, например, регресса.




----- Детали пирамиды тестирования -----

- Юнит-тесты (Unit Tests): Находятся на самом нижнем уровне пирамиды. Эти тесты фокусируются на проверке отдельных модулей или компонентов программы. 
Юнит-тесты обычно быстрые и их легко автоматизировать. Их должно быть больше всего в проекте.
В основе пирамиды лежат маленькие, дешевые и быстрые unit-тесты. За их написание и поддержку отвечает команда разработчиков. Весь старый и новый функционал должен быть подкреплен unit-тестами. Именно с их помощью можно быстро и комплексно проверить стабильность приложения.

- Интеграционные тесты (Integration Tests): Расположены на среднем уровне пирамиды. Они проверяют взаимодействие между различными модулями или компонентами. Интеграционные тесты могут быть медленнее и сложнее в поддержке, чем юнит-тесты.
Суть этого процесса в объединении программных модулей в группы и их последующее тестирование. Проще говоря, это проверка бизнес-логики без использования UI. На проекте интеграционные тесты пишут разработчики и они же их и поддерживают. Однако можно встретить команды, где этот уровень закрывает QA.

- Тесты пользовательского функционала / E2E тесты (End-to-End Tests): Находятся на вершине пирамиды. Эти тесты проверяют работу всей системы в условиях, максимально приближенных к реальным. Они часто включают в себя тестирование пользовательского интерфейса и могут быть довольно медленными и затратными. 
Здесь количество тестов должно быть наименьшим. Воссоздавая пользовательские сценарии, мы проверяем приложения на стабильность и работоспособность. На этом уровне тесты самые хрупкие.

В зависимости от проекта, команда может адаптировать стандартную пирамиду тестирования, чтобы лучше соответствовать его специфике и требованиям.
Пирамида тестирования на проекте в более подробном варианте может выглядеть, напрмер, вот так:

E2E tests            ---> QA
    ↑  
UI tests             ---> QA     
    ↑
API tests            ---> QA
    ↑
Integration tests    ---> QA, Dev
    ↑
Unit tests           ---> Dev





-------------- Альтернативные модели пирамиды тестирования -----------------

1) "Мороженое" или "Анти-пирамида".
В этой модели большой акцент делается на E2E тесты, а юнит-тесты почти отсутствуют. Это может привести к высоким затратам на поддержку и медленному процессу разработки.
По мере роста проекта форма пирамиды меняется, становясь больше похожей на мороженое (первёрнутая пирамида).
Такое случается при недостатке низкоуровневых тестов (модульных, интеграционных и компонентных), при избытке тестов, запускаемых через UI, и при ещё большем количестве сквозных (E2E) тестов.
Классическая "мороженка" тестирования, когда основной объем тестов сконцентрирован на поздних стадиях, преимущественно в виде ручного тестирования.
Чаще всего это происходит, когда над проектом работают несколько разных команд, возможно, изолированных друг от друга, и они добавляют тесты на разные уровни пирамиды. Например, разработчики пишут модульные и интеграционные тесты независимо от QA-инженеров, которые пишут сквозные тесты. Это приводит не только к неправильному распределению тестов по уровням пирамиды (потому что некоторые сценарии автоматизируются на нескольких разных уровнях), но ещё и к дублированию действий.

2) "Бутылка Колы".
Сосредоточение на интеграционных тестах, минимальное количество юнит-тестов и E2E тестов. Это может быть полезно для сложных систем с множеством взаимосвязей.

3) "Песочные часы".
В случае, если отсутствуют (или их очень мало) тесты среднего уровня (интеграционные), то пирамида превращается в песочные часы. В такой структуре много сквозных и модульных тестов, но мало интеграционных. Это не так плохо, как в случае с формой мороженого, но всё ещё приводит к слишком большому количеству падений сквозных тестов. В то же время, обнаружить баги приложения, которые приводят к падениям этих тестов, было бы быстрее и проще с помощью среднеуровневых тестов.









---------------- Что такое API ----------------

API (англ. Application Programming Interface — программный интерфейс приложения) — это набор способов и правил, по которым различные программы общаются между собой и обмениваются данными.
Все эти взаимодействия происходят с помощью функций, классов, методов, структур, а иногда констант одной программы, к которой обращаются другие. Это основной принцип работы API.

----- Где используется API -----

API позволяет интегрировать в программу функции, которые уже реализованы в другом приложении. Например, добавить на свой сайт «Яндекс.Карты» или подключить сервис email-рассылок к собственной СRМ-системе. 
То есть вам не нужно разрабатывать собственное ПО для решения типовой задачи, можно использовать готовый инструмент. Это позволит быстро внедрить функцию в проект и сэкономить деньги.

Допустим, вы покупаете билет в кино с помощью банковской карты. Во время покупки терминал обращается к API банка, который выпустил вашу карту, и отправляет запрос на оплату. А если вы заказываете такси через приложение, оно обращается к платёжной системе тоже через API.


